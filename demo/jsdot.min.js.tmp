
/*
This file is part of the JSDot library 

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini
Copyright (c) 2009 Lucia Blondel, Nicos Giuliani, Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

/** @class This is JSDot!
	<p>This is the interface you use to create views and editors.</p>
	
	<p>Arguments are optional, and can be used to create a view in
	just one line of code.</p>
	
	@param {String} divId id of a div tag where the view will be placed
	@param {String} options.mode type of view to create
	@param {String} options.json JSON representation of a graph to be loaded
*/
function JSDot(divId, options) {
	
	var views = [];
	var editors = [];
	
	/* instantiate the internal implementation */
	var jsdot = new JSDot.jsdot_Impl();
	
	/** Object to interact with the graph.
		@return {Graph} graph interface
	*/
	this.getGraph = function() {
		return new JSDot.Graph(jsdot, jsdot.graph);
	};
	
	/** Add a view
		@param {String} divId id of a div tag where the view will be placed
		@param {String} mode type of view to create
	*/
	this.addView = function(divId, mode) {
		if (views[divId]) return; /* view already exists */
		
		var v = new JSDot.View(jsdot, divId);
		JSDot.load_svg_shapes(v, 'shapes.svg');
		views[divId] = v;
		v.getTool('Layout.SpringEmbedder', {}); // FIXME: shouldn't be here
		var s = new JSDot.Selection(jsdot, v);
		switch (mode) {
			case 'drag':
				s.allowNodes = true;
				s.allowEdges = true;
				s.allowMultiple = true;
				s.allowDrag = true;
				jsdot.addEventHandler(v, new JSDot.Drag(jsdot, v, s));
				break;
			case 'editor':
				/* selection is set up by the editor itself */
				editors[divId] = new JSDot.Editor(jsdot, v, s);
			case 'hiddeneditor':
				break;
			case 'static':
			default:
				s.allowNodes = false;
				s.allowEdges = false;
				s.allowMultiple = false;
				s.allowDrag = false;
				break;
		};
	};
	
	/** Registers an event handler.
		When an event 'name' is triggered the function
		'handler' will be called.
		
		Use 'null' as 'view' to receive all the events,
		by giving the id of a view only the events generated by
		that view will trigger the handler.
		
		See {@link doc_Handler} for a list of events.
		
		@see doc_Handler
		
		@param {Object} view id of a view or null
		@param {String} name name of the event
		@param {Handler} handler handler function
	*/
	this.addEventHandler = function(view, name, handler) {
		jsdot.addEventHandler(view ? views[view] || null : null,
			name, handler);
	};
	
	/** Removes an event handler.
		The handler function must be exactly the same
		instance used when registering the event.
		
		@param {Object} view id of the view or null
		@param {String} name name of the event
		@param {Handler} handler handler function to remove
	*/
	this.removeEventHandler = function(view, name, handler) {
		jsdot.removeEventHandler(view ? views[view] || null : null,
			name, handler);
	};

	/** Get a tool.
		It must already have been instantiated.
	*/
	this.getTool = function(src, name) {
		var t = null;
		switch(src) {
			case 'graph':
				if (jsdot.tools['GraphTools'])
					t = jsdot.tools['GraphTools'][name];
				break;
			case 'view':
				if (jsdot.tools['ViewTools'])
					t = jsdot.tools['ViewTools'][name];
				break;
			case 'edit':
				if (jsdot.tools['EditTools'])
					t = jsdot.tools['EditTools'][name];
				break;
		}
		return t;
	};
	
	var t = jsdot.getTool('json', {});
	if (t) {
		this.importJSON = function(obj) { t.importGraph(obj); };
		this.exportJSON = function() { return t.exportGraph(); };
	}


	/****************************************/
	/* Handle constructor arguments, if any */
	/****************************************/
	
	if (typeof divId === 'string') {
		this.addView(divId, (options ? options.mode || '' : ''));
	}
	
	if (options && options.json && this.importJSON) {
		this.importJSON(options.json);
	}

};

/** This is where available tools are added.
	This is a namespace, tools will be defined as properties of this object.
*/
JSDot.GraphTools = {};
JSDot.ViewTools = { 'Layout': {} };
JSDot.EditTools = {};
/*
This file is part of the JSDot library 

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini
Copyright (c) 2009 Lucia Blondel, Nicos Giuliani, Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/** @class Helpers for JSDot
	Sort of globally available functions and properties.
*/
JSDot.helper = {

	svgns: "http://www.w3.org/2000/svg",
	xlinkns: "http://www.w3.org/1999/xlink",
	xmlns: "http://www.w3.org/2000/svg",
	xlink: "http://www.w3.org/1999/xlink",

	/** Create element in the SVG namespace. */
	cesvg: function(i){ return document.createElementNS(JSDot.helper.svgns, i); },

	/** Create a new stencil with a css class.
		@param {Object} options options collection
		@param {Object, String} options.shape shape to draw, must be in {@link JSDot.shapes}
		@param {String} options.cssClass css class of the node
		@param {String} options.cssHl css class for highlighting
		@param {Function} options.draw function for drawing
		@param {Function} options.setPosition function for setting position
		@param {Function} options.setSize function for updating size
		@param {Function} options.getBoundaryTo function calculating intersection between the shape and a line
		@param {Function} options.getBBox function calculating the bounding box of the shape
		@param {Function} options.highlight function called when the shape must be highlit
		@return {Object} stencil
	*/
	makeCssStencil: function(options){
		var res = {};
		options = options || {};
		if (typeof options.shape == "string") {
			res.shape = JSDot.shapes[options.shape] || JSDot.shapes.circle;
		} else {
			res.shape = options.shape || JSDot.shapes.circle;
		}
		
		res.cssClass = options.cssClass || 'jsdot_circle';
		res.cssHl = 'jsdot_def_hl';
		
		res.draw = options.draw || function(n, d, g) {
			this.shape.draw(n, d, g);
			g.setAttribute('class', this.cssClass);
		};
		
		res.setPosition = options.setPosition || function(n, d) {
			this.shape.setPosition(n, d);
		};
		
		res.setSize = options.setSize || function(n, d, s) {
			this.shape.setSize(n, d, s);
		};
		
		res.getBoundaryTo = options.getBoundaryTo || function(n, d, p) {
			return this.shape.getBoundaryTo(n, d, p);
		};
		
		res.getBBox = options.getBBox || function(n, d) {
			return this.shape.getBBox(n, d);
		};
		
		res.highlight = options.highlight || function(n, d, y) {
			if (y) {
				d.group.setAttribute('class', this.cssClass+' '+this.cssHl);
			} else {
				d.group.setAttribute('class', this.cssClass);
			};
		};
		
		return res;
	},
	
	/** Create a shape for edges.
		@param {Object} options options collection
		@param {String} options.markerStart link to arrow marker
		@param {String} options.markerEnd link to arrow marker
		@param {Function} options.draw function drawing the shape
		@param {Function} options.setPosition function updating edge position
		@return {Object} edge shape
	*/
	makeEdgeShape: function(options) {
		var res = {};
		options = options || {};
		
		res.markerStart = options.markerStart;
		res.markerEnd = options.markerEnd;
		
		res.draw = options.draw || function(e, d, p) {
			var l = JSDot.helper.cesvg('path');
			d.line = l;
			if (this.markerStart) l.setAttribute('marker-start', this.markerStart);
			if (this.markerEnd) l.setAttribute('marker-end', this.markerEnd);
			p.appendChild(l);
			l = JSDot.helper.cesvg('path');
			d.handle = l;
			l.setAttribute('class', 'jsdot-edge-handle');
			p.appendChild(l);
			return l;
		};
		
		res.setPosition = options.setPosition || function(e, d) {
			var p1 = d.start;
			var p2 = d.end;
			d.line.setAttribute(
				'd', 'M'+p1[0]+','+p1[1]+'L'+p2[0]+','+p2[1]
			);
			d.handle.setAttribute(
				'd', 'M'+p1[0]+','+p1[1]+'L'+p2[0]+','+p2[1]
			);
		};
		
		return res;
	},
	
	/** Create an edge stencil.
		@param {Object} options options collection
		@param {Object, String} options.shape shape to draw, must be in {@link JSDot.edge_shapes}
		@param {String} options.cssClass css class of the edge
		@param {String} options.cssHl css class for highlighting
		@param {Function} options.draw function for drawing
		@param {Function} options.setPosition function for setting position
		@param {Function} options.highlight function called when the shape must be highlit
		@return {Object} stencil
	*/
	makeEdgeStencil: function(options) {
		var res = {};
		options = options || {};
		
		if (typeof options.shape == 'string') {
			res.shape = JSDot.edge_shapes[options.shape] || JSDot.edge_shapes.line;
		} else {
			res.shape = options.shape || JSDot.edge_shapes.line;
		}
		
		res.cssClass = options.cssClass || 'jsdot_line_edge';
		res.cssHl = options.cssHl || 'jsdot_def_hl';
		
		res.draw = options.draw || function(e, d, p) {
			this.shape.draw(e, d, p);
			p.setAttribute('class', this.cssClass);
		};
		
		res.setPosition = options.setPosition || function(e, d) {
			this.shape.setPosition(e, d);
		};
		
		res.highlight = options.highlight || function(e, d, y) {
			if (y) {
				d.group.setAttribute('class', this.cssClass+' '+this.cssHl);
			} else {
				d.group.setAttribute('class', this.cssClass);
			};
		};
		
		return res;
	}
};
/*
This file is part of the JSDot library 

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini
Copyright (c) 2009 Lucia Blondel, Nicos Giuliani, Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

/** Construct a JSDot instance.
	@class JSDot implementation
	Handles events dispatching.

	@constructor
*/
JSDot.jsdot_Impl = function() {

	/** Registered event handlers.
		@private
		@see addEventHandler
		@see fireEvent
	*/
	this.handlers = {};
	
	/** Attached graph.
		The graph on which the instance is working.
		@type Graph_impl
	*/
	this.graph = new JSDot.Graph_impl(this);
	
	/** Tool instances.
		This is a pool where instantiated tools are stored.
		@see getTool
	*/
	this.tools = {};

};

JSDot.jsdot_Impl.prototype = {

	/** Registers an event handler.
		When an event 'name' is triggered the function
		'handler' will be called.
		
		May also be called as addEventHandler(obj, handler_obj),
		in this case handler_obj may define functions for more events.
		
		@param {Object} obj object generating events
		@param {String} name name of the event
		@param {Handler} handler handler function
	*/
	addEventHandler: function(obj, name, handler) {
		if (typeof name == "string") {
			/* use case 1: single handler function */
			
			if (typeof handler != "function") return;

			/* create the entry for the event if it doesn't exist */
			if (!this.handlers[name]) this.handlers[name] = [];
			
			/* add handler */
			this.handlers[name].push([obj, handler]);
			
		} else {
			/* use case 2: handler object in 'name' */
			for (var i in name) {
				this.addEventHandler(obj, i, name[i]);
			}
		}
	},
	
	/** Removes an event handler.
		The handler function (or object) must be exactly the same
		instance used when registering the event.
		
		May also be called as addEventHandler(obj, handler_obj),
		in this case handler_obj may define functions for more events.
		
		@param {Object} obj object generating events
		@param {String} name name of the event
		@param {Handler} handler handler function to remove
	*/
	removeEventHandler: function(obj, name, handler) {
		if (typeof name == "string") {
			if (typeof handler != "function") return;
			if (!this.handlers[name]) return;
			var h = this.handlers[name];
			for (var i in h) {
				if (h[i][0] == obj && h[i][1] == handler) {
					h.splice(i, 1);
					return;
				}
			}
		} else {
			/* 'name' is the handler object */
			for (var i in name) {
				this.removeEventHandler(obj, i, name[i]);
			}
		}
	},

	/** Triggers an event.
		Calls all registered event handlers for event 'name'.
		@param {Object} obj source of the event
		@param {String} name name of the events
		@param {Object} arguments any following arguments will be passed on to the handler
	*/
	fireEvent: function() {
		var obj = Array.prototype.shift.apply(arguments);
		var name = Array.prototype.shift.apply(arguments); // remove name
		
		if (!this.handlers[name]) return;
		for (var i in this.handlers[name]) {
			var e = this.handlers[name][i];
			if (obj == null || e[0] == null || e[0] == obj) {
				e[1].apply(obj, arguments);
			}
		}
	},
	
	/** Get a tool.
		@private
		@param {String} src one of ViewTools, EditTools or GraphTools
		@param {String} tool name of the tool
		@param {Object} params parameters passed to the tool's init function, if it exists
	*/
	getToolI: function(src, tool, params) {
		var r = this.tools[src];
		if (!r) r = this.tools[src] = {};
		
		/* if there is already an instance return it */
		if (r[tool]) return r[tool];
		
		/* resolve tool names like 'Layout.Spring' */
		var t = JSDot[src];
		var tpath = tool.split('.');
		for (var i in tpath) {
			t = t[tpath[i]];
			if (!t) return null;
		}
		
		/* tool is not defined */
		if (!t) return null;
		
		if (typeof t == 'function') {
			/* it has a constructor, so use it */
			var i = new t;
			if (typeof i.init == 'function') {
				/* there is an init function, and we call it with parameters */
				if (!i.init(params)) {
					return null;
				}
			}
			r[tool] = i;
			return i;
			
		} else if (typeof t == 'object') {
			/* use it directly */
			r[tool] = t;
			return t;
		}
		
		return null;
	},
	
	/** Return an instance of a tool for the current graph.
		If 'params' exists, a reference to the graph will be added to it.
		@param {String} tool name of the tool
		@param {Object} params parameters passed to the tool's init function, if it exists
		@return {Object} the requested tool or null
	*/
	getTool: function(tool, params) {
		if (params) params.graph = this.graph;
		return this.getToolI('GraphTools', tool, params);
	},

};
/*
This file is part of the JSDot library 
 
http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

/** @class Node internal representation.
	@constructor
	Creates a new node.
	@param {JSDot.Graph_impl} graph graph to which the new node belongs
	@param {String} name name of the new node
*/
JSDot.Node_impl = function(graph, name) {

	/** Graph containing the node.
		@type JSDot.Graph_impl
	*/
	this.graph = graph;
	
	/** Name identifying the node inside the graph. */
	this.name = name;
	
	/** Label of the node.
		@see setLabel
	*/
	this.label = {'type': 'plain', 'value': name};
	
	/** Position of the node.
		Array [x,y].
		@see setPosition
	*/
	this.position = [0,0];
	
	/** Name of the stencil to be used to represent the node.
		@type String
		@see setStencil
	*/
	this.stencil = graph.defaultNodeStencil;
	
	/** List of edges connected to this node.
		Elements are {@link JSDot.Edge_impl} instances indexed by their id.
	*/
	this.edges = {};
	
	/** This can be arbitrary data attached to the node.
		@see setData
		@see getData
	*/
	this.userData = {};
	
	/** Distiguishes between nodes and edges. */
	this.isNode = true;
};

JSDot.Node_impl.prototype = {

	/** Set node's label.
		Fires a {@link doc_Handler.changed} event.
		@param {String} l new label
		@param {Boolean} fire whether to fire the event or not, default is true
	*/
	setLabel: function(l, fire) {
		if (this.label) {
			this.label.value = l;
		} else {
			this.label = {'type': 'plain', 'value': l};
		}
		if (fire == undefined || fire) this.graph.jsdot.fireEvent(this.graph, 'changed', this);
	},
	
	/** Set node's position.
		Fires a {@link doc_Handler.moved} event.
		@param {Array} p new position in the form [x, y]
		@param {Boolean} fire whether to fire the event or not, default is true
	*/
	setPosition: function(p, fire) {
		this.position = p;
		if (fire == undefined || fire) this.graph.jsdot.fireEvent(this.graph, 'moved', this);
	},

	/** Set node stencil.
		Set which stencil should be used to draw the node.
		<br>If the choosen stencil doesn't exist, the default one is set.
		<br>Fires a {@link doc_Handler.changed} event.
		@param {String} name name of the stencil
		@param {Boolean} fire whether to fire the event or not, default is true
	*/
	setStencil: function(name, fire) {
		this.stencil = name;
		if (fire == undefined || fire) this.graph.jsdot.fireEvent(this.graph, 'changed', this);
	},
	
	/** Attach data to the node.
		You will have to use {@link getData}(key) to retrieve it
		at a later time.
		@param {String} key index identifying data
		@param {Object} value the value to store
	*/
	setData: function(key, value) {
		this.userData[key] = value;
	},
	
	/** Retrive data attached to the node.
		Retrieve data which has been set using {@link setData}.
		@param {String} key index identifying data
		@return {Object} attached data identified by key
	*/
	getData: function(key) {
		return this.userData[key];
	},

};
/*
This file is part of the JSDot library 

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini
Copyright (c) 2009 Lucia Blondel, Nicos Giuliani, Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

/** @class Node API
	API to modify a node.
	@constructor
	@private
	Create an object that can be used to modify a node.
	@param {Node_impl} impl internal representation of the node that will be modified
*/
JSDot.Node = function(jsdot, impl) {

	/** Node's name.
		Returns the name identifying the node inside the graph.
		@return {String} node's name
	*/
	this.getName = function() {
		return impl.name;
	};

	/** Set node's label.
		Fires a {@link doc_Handler.changed} event.
		@param {String} l new label
	*/
	this.setLabel = function(l) {
		impl.setLabel(l);
	};
	
	/** Set node's position.
		Fires a {@link doc_Handler.moved} event.
		@param {Array} p new position in the form [x, y]
	*/
	this.setPosition = function(p) {
		impl.setPosition(p);
	};
	
	/** Returns node's current position.
		@retun {Array} node's position in the form [x, y]
	*/
	this.getPosition = function() {
		return impl.position;
	};

	/** Set node stencil.
		Set which stencil should be used to draw the node.
		<br>If the choosen stencil doesn't exist, the default one is set.
		<br>Fires a {@link doc_Handler.changed} event.
		@param {String} name name of the stencil
	*/
	this.setStencil = function(name) {
		impl.setStencil(name);
	};

};
/*
This file is part of the JSDot library 

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

/** @class Edge internal representation.
	@constructor
	Creates a new edge.
	@param {JSDot.Graph_impl} graph graph to which the new node belongs
	@param {String} id id of the new edge
	@param {JSDot.Node_impl} starting node
	@param {JSDot.Node_impl} dst ending node
*/
JSDot.Edge_impl = function(graph, id, src, dst) {

	/** Graph containing the edge.
		@type JSDot.Graph_impl
	*/
	this.graph = graph;
	
	/** Edge identification. */
	this.id = id;
	
	/** Node where the edge starts.
		@type JSDot.Node_impl
	*/
	this.src = src;
	
	/** Node where the edge terminates.
		@type JSDot.Node_impl
	*/
	this.dst = dst;
	
	/** Label of the edge.
		@see setLabel
	*/
	this.label = null;
	
	/** Name of the stencil to be used to represent the edge.
		@type String
		@see setStencil
	*/
	this.stencil = graph.defaultEdgeStencil;
	
	/** This can be arbitrary data attached to the edge.
		@see setData
		@see getData
	*/
	this.userData = {};
	
	/** Distiguishes between nodes and edges. */
	this.isEdge = true;
};

JSDot.Edge_impl.prototype = {

	/** Set edge's label.
		Fires a {@link doc_Handler.changed} event.
		@param {String} l new label
		@param {Boolean} fire whether to fire a {@link doc_Handler.changed} event or not, default is true
	*/
	setLabel: function(l, fire) {
		if (this.label) {
			this.label.value = l;
		} else {
			this.label = {'type': 'plain', 'value': l};
		}
		if (fire == undefined || fire) this.graph.jsdot.fireEvent(this.graph, 'changed', this);
	},

	/** Set edge stencil.
		Set which stencil should be used to draw the edge.
		<br>If the choosen stencil doesn't exist, the default one is set.
		@param {String} name name of the stencil
		@param {Boolean} fire whether to fire a {@link doc_Handler.changed} event or not, default is true
	*/
	setStencil: function(name, fire) {
		this.stencil = name;
		if (fire == undefined || fire) this.graph.jsdot.fireEvent(this.graph, 'changed', this);
	},
	
	/** Attach data to the edge.
		You will have to use {@link getData}(key) to retrieve it
		at a later time.
		@param {String} key index identifying data
		@param {Object} value the value to store
	*/
	setData: function(key, value) {
		this.userData[key] = value;
	},
	
	/** Retrive data attached to the edge.
		Retrieve data which has been set using {@link setData}.
		@param {String} key index identifying data
		@return {Object} attached data identified by key
	*/
	getData: function(key) {
		return this.userData[key];
	},

};
/*
This file is part of the JSDot library 

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

/** @class Edge API
	API to modify an edge.
	@constructor
	@private
	Create an object that can be used to modify an edge.
	@param {Edge_impl} impl internal representation of the edge that will be modified
*/
JSDot.Edge = function(jsdot, impl) {

	/** Set edge stencil.
		Set which stencil should be used to draw the edge.
		<br>If the choosen stencil doesn't exist, the default one is set.
		@param {String} name name of the stencil
	*/
	this.setStencil = function(name) {
		impl.setStencil(name);
	};

	/** Set edge's label.
		Fires a {@link doc_Handler.changed} event.
		@param {String} l new label
	*/
	this.setLabel = function(l) {
		impl.setLabel(l);
	};

};
/*
This file is part of the JSDot library 
 
http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini
Copyright (c) 2009 Lucia Blondel, Nicos Giuliani, Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

/** Constructs a graph representation.
	@class Graph representation

	@constructor
	@param {JSDot.jsdot_Impl} jsdot JSDot instance
*/
JSDot.Graph_impl = function(jsdot) {

	/** Associated JSDot instance. 
		@type JSDot.jsdot_Impl
	*/
	this.jsdot = jsdot;
	
	/** Name of the stencil applied to created nodes.
		@type String
	*/
	this.defaultNodeStencil = 'circle';
	
	/** Name of the stencil applied to created edges.
		@type String
	*/
	this.defaultEdgeStencil = 'line';

	/** Nodes in the graph.
		List of {@link JSDot.Node_impl} indexed by their name.
	*/
	this.nodes = {};
	
	/** Edges in the graph.
		List of {@link JSDot.Edge_impl} indexed by their id.
	*/
	this.edges = {};
	
	/** Incremental name for new nodes.
		@private
	*/
	this.lastName = 0;
	
	/** Incremental index for edges.
		@private
	*/
	this.lastEId = 0;

};

JSDot.Graph_impl.prototype = {

	/** Clear graph.
		<p>Removes all content of current graph.</p>
		<p>This is different than creating a new graph in that all references
		to this graph will still point to the cleared one, instead of pointing
		to the old (unchanged) instance.</p>
	*/
	clear: function() {
		JSDot.Graph_impl.call(this, this.jsdot);
		this.fireGraphEvent('newgraph');
	},
	
	/** Returns a node by name.
		@param {String} name name of the node
		@return {Node} the node or undefined
	*/
	getNodeByName: function(name) {
		return this.nodes[name];
	},
	
	/** Create a new node in the current graph.
		If a name is provided, and a node with the same name already exists
		returns null. If no name is given the next incremental one is used.
		@param {String} name (optional) name of the node
		@param {Boolean} fire whether to fire a {@link doc_Handler.created} event or not, default is true
		@return {JSDot.Node_impl} the created node
	*/
	createNode: function(name, fire) {
		var nn; // node name
		
		if (name) {
			/* use the provided name, if it doesn't alredy exist */
			nn = name;
			if (this.nodes[nn]) return null;
		} else {
			/* generate a name which isn't already used */
			do {nn = ++this.lastName;} while (this.nodes[nn]);
		}
		
		var n = new JSDot.Node_impl(this, nn);
		
		this.nodes[nn] = n;
		if (fire == undefined || fire) this.jsdot.fireEvent(this, 'created', n);
		return n;
	},
	
	/** Create a new edge in the current graph.
		@param {JSDot.Node_impl} src starting node
		@param {JSDot.Node_impl} dst ending node
		@param {Boolean} fire whether to fire a {@link doc_Handler.created} event or not, default is true
		@return {JSDot.Edge_impl} the created edge
	*/
	createEdge: function(src, dst, fire) {
		var id; // node name
		/* generate an index which isn't already used */
		do {id = ++this.lastEId;} while (this.edges[id]);
		
		var e = new JSDot.Edge_impl(this, id, src, dst);
		
		src.edges[id] = e;
		dst.edges[id] = e;
		
		this.edges[id] = e;
		if (fire == undefined || fire) this.jsdot.fireEvent(this, 'created', e);
		return e;
	},
	
	/** Remove a node from current graph.
		@param {Node_impl} n node to remove
		@param {Boolean} fire whether to fire a {@link doc_Handler.removed} event or not, default is true
	*/
	removeNode: function(n, fire) {
		/* remove edges */
		var e;
		for (id in n.edges) {
			e = n.edges[id];
			/* remove edge from the other connected node, but not from the one we are removing */
			if (e.src == n) {
				delete e.dst.edges[id];
			} else {
				delete e.src.edges[id];
			}
			delete this.edges[id];
		}
		
		delete this.nodes[n.name];
		if (fire == undefined || fire) this.jsdot.fireEvent(this, 'removed', n);
	},
	
	/** Remove an edge from current graph.
		@param {Edge_impl} e edge to remove
		@param {Boolean} fire whether to fire a {@link doc_Handler.removed} event or not, default is true
	*/
	removeEdge: function(e, fire) {
		delete this.edges[e.id];
		delete e.src.edges[e.id];
		delete e.dst.edges[e.id];
		if (fire == undefined || fire) this.jsdot.fireEvent(this, 'removed', e);
	},
	
	/** Change the default stencils of this graph.
		If the new stencil given as argument doesn't exist the default
		will not be changed.
		@param {String} node stencil name for nodes
		@param {String} edge stencil name for edges
	*/
	setDefaultStencils: function(node, edge) {
		if (node && JSDot.stencils[node]) this.defaultNodeStencil = node;
		if (edge && JSDot.edge_stencils[edge]) this.defaultEdgeStencil = edge;
	},
	
	/** Fire an event affecting this graph.
		This is a shorthand to call {@link JSDot.jsdot_Impl.fireEvent} with this
		graph as first argument.
		@see JSDot.jsdot_Impl.fireEvent
		@see doc_Handler
	*/
	fireGraphEvent: function() {
		Array.prototype.unshift.call(arguments, this);
		return this.jsdot.fireEvent.apply(this.jsdot, arguments);
	},

};
/*
This file is part of the JSDot library 

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini
Copyright (c) 2009 Lucia Blondel, Nicos Giuliani, Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

/** @class Graph API
	API to populate and modify a graph.
	@constructor
	@private
	Create an object that can be used to modify a graph.
	@param {jsdot_Impl} jsdot jsdot instance
	@param {Graph_impl} graph internal representation of the graph that will be modified
*/
JSDot.Graph = function(jsdot, graph) {

	/** Creates a new node.
		Fires a {@link doc_Handler.created} event.<br>
		If a name is provided, and a node with the same name already exists
		returns null.
		@param {String} name (optional) name of the node
		@return {JSDot.Node} the new node
	*/
	this.createNode = function(name) {
		var n = graph.createNode(name);
		if (n) {
			return new JSDot.Node(jsdot, n);
		} else {
			return null;
		}
	};

	/** Create an edge between two nodes.
		@param {JSDot.Node} src starting {@link JSDot.Node} or its name
		@param {JSDot.Node} dst ending {@link JSDot.Node} or its name
		@return {JSDot.Edge} the new edge
	*/
	this.createEdge = function(src, dst) {
		if (typeof src != 'string') src = src.getName();
		if (typeof dst != 'string') dst = dst.getName();
		var e = graph.createEdge(graph.nodes[src], graph.nodes[dst]);
		return new JSDot.Edge(jsdot, e);
	};
	
	/** Clear graph.
		Removes all content of the graph.
	*/
	this.clear = function() {
		graph.clear();
	};

};
/*
 This file is part of the JSDot library
 
 http://code.google.com/p/jsdot/
 
 Copyright (c) 2010 Carlo Vanini
 Copyright (c) 2009 Lucia Blondel, Nicos Giuliani, Carlo Vanini
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */

/** Node shapes.
	The shape of a node. It is drawn by using a @ref stencil.
*/
JSDot.shapes = {

	'circle': {
	
		size: '2.5em',
		
		draw: function(n, d, g) {
			var c = JSDot.helper.cesvg('circle');
			c.setAttribute('r', this.size);
			g.appendChild(c);
			d.shape = c;
			return c;
		},
		
		setPosition: function(n, d) {
			var s = d.shape;
			s.setAttribute('cx', n.position[0]);
			s.setAttribute('cy', n.position[1]);
		},
		
		getBoundaryTo: function(n, d, p) {
			var c = n.position; // node center
			var a = Math.atan2((p[1]-c[1]), (p[0]-c[0]));
			var size = d.shape.r.baseVal.value;
			return [
				c[0] + Math.cos(a) * size,
				c[1] + Math.sin(a) * size
			];
		},
		
		getBBox: function(n, d) {
			return d.shape.getBBox();
		},
		
		setSize: function(n, d, s) {
			d.shape.setAttribute('r', Math.max(s.height,s.width)/2+6);
		}
	},
	
	'box': {
		draw: function(n, d, g) {
			var e = JSDot.helper.cesvg('rect');
			e.setAttribute('height', 30);
			e.setAttribute('width', 50);
			g.appendChild(e);
			d.shape = e;
			return e;
		},
		
		setPosition: function(n, d) {
			var s = d.shape;
			s.setAttribute('x', n.position[0] - s.width.baseVal.value / 2);
			s.setAttribute('y', n.position[1] - s.height.baseVal.value / 2);
		},
		
		getBoundaryTo: function(n, d, p) {
		
			//get rect dimensions
			var x = d.shape.x.baseVal.value; /* left */
			var y = d.shape.y.baseVal.value; /* top */
			var height = d.shape.height.baseVal.value;
			var width = d.shape.width.baseVal.value;
			
			var xl = x; /* left edge of rect */
			var xr = x + width; /* right edge of rect */
			var slope = (p[1]-(y+height/2)) / (p[0]-(x+width/2));
			/* division by 0 gives Infinity, which is fine! */
			
			if (Math.abs(p[1] - (y+height/2)) < 2) {
				/* p is on a horizontal line with the center */
				if (p[0] < xr) {
					return [xl, p[1]];
				} else {
					return [xr, p[1]];
				}
			} else if (p[1] < y+height/2) {
				/* intersection with upper part of rect */
				var iup = (y-p[1]) / slope + p[0];
				if (iup < xl) {
					/* intersection on left side */
					var il = (xl-p[0]) * slope + p[1];
					return [xl, il];
				} else if (iup > xr) {
					/* intersection on right side */
					var ir = (xr-p[0]) * slope + p[1];
					return [xr, ir];
				} else {
					/* intersection on top */
					return [iup, y];
				}
			} else {
				/* intersection with bottom part of rect */
				var ibt = (y+height-p[1]) / slope + p[0];
				if (ibt < xl) {
					/* intersection on left side */
					var il = (xl-p[0]) * slope + p[1];
					return [xl, il];
				} else if (ibt > xr) {
					/* intersection on right side */
					var ir = (xr-p[0]) * slope + p[1];
					return [xr, ir];
				} else {
					/* intersection on top */
					return [ibt, y+height];
				}
			}
		},
		
		getBBox: function(n, d) {
			return d.shape.getBBox();
		},
		
		setSize: function(n, d, s) {
			var p = d.shape;
			p.setAttribute('height', s.height+3);
			p.setAttribute('width', s.width+10);
			this.setPosition(n, d);
		}
	},
	
	'hexagon': {
	
		dw: 2,
		dh: 2,
		ew: 15,
		
		draw: function(n, d, g) {
			var e = JSDot.helper.cesvg('polygon');
			//e.setAttribute('points', '');
			g.appendChild(e);
			d.shape = e;
			return e;
		},
		
		setPosition: function(n, d) {
			d.shape.setAttribute('transform', 'translate('+n.position[0]+' '+n.position[1]+')');
		},
		
		getBoundaryTo: function(n, d, p) {
		
			//get rect dimensions
			var height = d.size.height;
			var width = d.size.width;
			var x = n.position[0] - width/2;  /* left */
			var y = n.position[1] - height/2; /* top */
			
			var xl = x; /* left edge of rect */
			var xr = x + width; /* right edge of rect */
			var slope = (p[1]-n.position[1]) / (p[0]-n.position[0]);
			/* division by 0 gives Infinity, which is fine! */
			
			if (Math.abs(p[1] - (y+height/2)) < 2) {
				/* p is on a horizontal line with the center */
				if (p[0] < xr) {
					return [xl-this.ew, p[1]];
				} else {
					return [xr+this.ew, p[1]];
				}
			} else if (p[1] < y+height/2) {
				/* intersection with upper part of rect */
				var iup = (y-p[1]) / slope + p[0];
				if (iup < xl) {
					/* intersection on left side */
					var s2 = -(height/2) / this.ew; /* slope of the diagonal side */
					var ix = (s2*xl - y - slope*p[0] + p[1]) / (s2 - slope);
					return [ix, (ix-xl) * s2 + y];
				} else if (iup > xr) {
					/* intersection on right side */
					var s2 = (height/2) / this.ew; /* slope of the diagonal side */
					var ix = (s2*xr - y - slope*p[0] + p[1]) / (s2 - slope);
					return [ix, (ix-xr) * s2 + y];
				} else {
					/* intersection on top */
					return [iup, y];
				}
			} else {
				/* intersection with bottom part of rect */
				var ibt = (y+height-p[1]) / slope + p[0];
				if (ibt < xl) {
					/* intersection on left side */
					var s2 = (height/2) / this.ew; /* slope of the diagonal side */
					var ix = (s2*xl - (y+height) - slope*p[0] + p[1]) / (s2 - slope);
					return [ix, (ix-xl) * s2 + y+height];
				} else if (ibt > xr) {
					/* intersection on right side */
					var s2 = -(height/2) / this.ew; /* slope of the diagonal side */
					var ix = (s2*xr - (y+height) - slope*p[0] + p[1]) / (s2 - slope);
					return [ix, (ix-xr) * s2 + y+height];
				} else {
					/* intersection on top */
					return [ibt, y+height];
				}
			}
		},
		
		getBBox: function(n, d) {
			var b = d.shape.getBBox();
			b.x += n.position[0];
			b.y += n.position[1];
			return b;
		},
		
		setSize: function(n, d, s) {
			var w = s.width/2 + this.dw;
			var h = s.height/2 + this.dh;
			var p = [
				-w, -h, /* top left */
				w, -h,  /* top right */
				w+this.ew, 0,/* > right */
				w, h,   /* bottom right */
				-w, h,  /* bottom left */
				-w-this.ew, 0/* < left */
			];
			d.shape.setAttribute('points', p.join(' '));
			d.size = { height: s.height + 2*this.dh, width: s.width + 2*this.dw }; /* needed by getBoundaryTo */
		}
	},
	
	'concave hexagon': {
	
		dw: 8,
		dh: 2,
		ew: 15,
		
		draw: function(n, d, g) {
			var e = JSDot.helper.cesvg('polygon');
			//e.setAttribute('points', '');
			g.appendChild(e);
			d.shape = e;
			return e;
		},
		
		setPosition: function(n, d) {
			d.shape.setAttribute('transform', 'translate('+n.position[0]+' '+n.position[1]+')');
		},
		
		getBoundaryTo: function(n, d, p) {
		
			//get rect dimensions
			var height = d.size.height;
			var width = d.size.width;
			var x = n.position[0] - width/2 - this.ew;  /* left */
			var y = n.position[1] - height/2; /* top */
			
			var xl = x; /* left edge of rect */
			var xr = x + width + 2*this.ew; /* right edge of rect */
			var slope = (p[1]-n.position[1]) / (p[0]-n.position[0]);
			/* division by 0 gives Infinity, which is fine! */
			
			if (Math.abs(p[1] - (y+height/2)) < 2) {
				/* p is on a horizontal line with the center */
				if (p[0] < xr) {
					return [xl+this.ew, p[1]];
				} else {
					return [xr-this.ew, p[1]];
				}
			} else if (p[1] < y+height/2) {
				/* intersection with upper part of rect */
				var iup = (y-p[1]) / slope + p[0];
				if (iup < xl) {
					/* intersection on left side */
					var s2 = (height/2) / this.ew; /* slope of the diagonal side */
					var ix = (s2*xl - y - slope*p[0] + p[1]) / (s2 - slope);
					return [ix, (ix-xl) * s2 + y];
				} else if (iup > xr) {
					/* intersection on right side */
					var s2 = -(height/2) / this.ew; /* slope of the diagonal side */
					var ix = (s2*xr - y - slope*p[0] + p[1]) / (s2 - slope);
					return [ix, (ix-xr) * s2 + y];
				} else {
					/* intersection on top */
					return [iup, y];
				}
			} else {
				/* intersection with bottom part of rect */
				var ibt = (y+height-p[1]) / slope + p[0];
				if (ibt < xl) {
					/* intersection on left side */
					var s2 = -(height/2) / this.ew; /* slope of the diagonal side */
					var ix = (s2*xl - (y+height) - slope*p[0] + p[1]) / (s2 - slope);
					return [ix, (ix-xl) * s2 + y+height];
				} else if (ibt > xr) {
					/* intersection on right side */
					var s2 = (height/2) / this.ew; /* slope of the diagonal side */
					var ix = (s2*xr - (y+height) - slope*p[0] + p[1]) / (s2 - slope);
					return [ix, (ix-xr) * s2 + y+height];
				} else {
					/* intersection on top */
					return [ibt, y+height];
				}
			}
		},
		
		getBBox: function(n, d) {
			var b = d.shape.getBBox();
			b.x += n.position[0];
			b.y += n.position[1];
			return b;
		},
		
		setSize: function(n, d, s) {
			var w = s.width/2 + this.dw;
			var h = s.height/2 + this.dh;
			var p = [
				-w-this.ew, -h, /* top left */
				w+this.ew, -h,  /* top right */
				w, 0,/* > right */
				w+this.ew, h,   /* bottom right */
				-w-this.ew, h,  /* bottom left */
				-w, 0/* < left */
			];
			d.shape.setAttribute('points', p.join(' '));
			d.size = { height: s.height + 2*this.dh, width: s.width + 2*this.dw }; /* needed by getBoundaryTo */
		}
	},
};

/** Node stencils.
	Stencils are composed by a shape and
	a style, which may be defined in css.
	
	Differenct stencils may share the same shape and apply
	different styles.
*/
JSDot.stencils = {

	'circle': JSDot.helper.makeCssStencil(),
	
	'box': JSDot.helper.makeCssStencil({
		shape: JSDot.shapes.box,
		cssClass: 'jsdot_box'
		}),
	
	'hexagon': JSDot.helper.makeCssStencil({
		shape: JSDot.shapes.hexagon,
		cssClass: 'jsdot_hexagon'
		}),
	
	'concave hexagon': JSDot.helper.makeCssStencil({
		shape: JSDot.shapes['concave hexagon'],
		cssClass: 'jsdot_concave_hexagon'
		}),
};

/** Edge shapes.
*/
JSDot.edge_shapes = {

	'line': JSDot.helper.makeEdgeShape(),

	'directed line': JSDot.helper.makeEdgeShape({
		markerEnd: 'url(#Arrow)'
		}),

	'bidi line': JSDot.helper.makeEdgeShape({
		markerStart: 'url(#ArrowS)',
		markerEnd: 'url(#Arrow)'
		}),
};

/** Edge stencils.
	Stencils used to draw edges.
*/
JSDot.edge_stencils = {

	'line': JSDot.helper.makeEdgeStencil(),

	'directed line': JSDot.helper.makeEdgeStencil({
		shape: JSDot.edge_shapes['directed line'],
		cssClass: 'jsdot_dirline_edge'
		}),

	'bidi line': JSDot.helper.makeEdgeStencil({
		shape: JSDot.edge_shapes['bidi line'],
		cssClass: 'jsdot_bidiline_edge'
		}),
};

/** Insert external SVG elements.
	@private
	This is a workaround, since url() references added from
	javascript are not loaded.
	
	@param {jsdot_View} view view of a JSDot instance to which the elements will be added
	@param {String} file SVG file to load
*/
JSDot.load_svg_shapes = function(view, file) {

	var request = new XMLHttpRequest();
	if (request.overrideMimeType) {
		request.overrideMimeType('text/xml')
	}
	request.open("GET", file, false); // synchronous
	request.send();
	
	//if (request.status != 200) return;
	
	var xml = request.responseXML;
	var defs = xml.getElementsByTagName('defs')[0];
	defs.parentNode.removeChild(defs);
	view.svgroot.appendChild(defs);

return;

/*
	var defs = $e('defs');
	view.svgroot.appendChild(defs);
	
	
	// Arrow
	var m = $e('marker');
	m.setAttrs({
		'id': 'Arrow',
		'refy': '0.0',
		'refx': '30',
		'orient': 'auto',
		'style': 'overflow:visible;'
	});
	var l = $e('path');
	l.setAttrs({
		'transform': 'scale(1.1) rotate(180) translate(1,0)',
		'd': 'M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z'
	});
	m.appendChild(l);
	defs.appendChild(m);
*/
};

/** Stencils for drawing labels.
*/
JSDot.node_label_stencils = {

	'plain': {
	
		draw: function(n, d, p) {
			var t = JSDot.helper.cesvg('text');
			t.setAttribute('class', 'jsdot_node_label');
			t.textContent = n.label.value;
			p.appendChild(t);
			d.label = t;
			return t;
		},
		
		setPosition: function(n, d) {
			var l = d.label;
			l.setAttribute('x', n.position[0]);
			l.setAttribute('y', n.position[1]);
		},
		
		getSize: function(n, d) {
			return d.label.getBBox();
			//return n.view.label.getBoundingClientRect();
		},
	},
};

/** Stencils for drawing edge labels.
*/
JSDot.edge_label_stencils = {

	'plain': {
	
		draw: function(n, d, p) {
			var t = JSDot.helper.cesvg('text');
			t.setAttribute('class', 'jsdot-edge-label');
			t.textContent = n.label.value;
			p.appendChild(t);
			d.label = t;
			return t;
		},
		
		setPosition: function(n, d) {
			var p1 = d.start;
			var p2 = d.end;
			var l = d.label;
			l.setAttribute('x', p1[0]+(p2[0]-p1[0])/2);
			l.setAttribute('y', p1[1]+(p2[1]-p1[1])/2);
		},
		
		getSize: function(n, d) {
			return d.label.getBBox();
			//return n.view.label.getBoundingClientRect();
		},
	},
};
/*
 This file is part of the JSDot library
 
 http://code.google.com/p/jsdot/
 
 Copyright (c) 2010 Carlo Vanini
 Copyright (c) 2009 Lucia Blondel, Nicos Giuliani, Carlo Vanini
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */

/**
	Construct a new view.
	@class Graph visualization.
	This paints the SVG.
	@constuctor
	@param {JSDot} jsdot JSDot instance
	@param {String} divId id of the div container
*/
JSDot.View = function(jsdot, divId) {

	/** Associated JSDot instance. */
	this.jsdot = jsdot;
	
	/** Id of the containing div tag. */
	this.divId = divId;
	
	/** Containing div element. */
	this.container = document.getElementById(divId);
	this.container.setAttribute('class',
		(this.container.getAttribute('class')||'') + ' jsdot-container');
	
	/** SVG owning document. */
	this.svgdoc = this.container.ownerDocument;
	
	var div = document.createElement('div'); // used to get the offset of the svg inside the page
	this.container.appendChild(div);
	
	/** SVG element.
		This is where we draw.
	*/
	this.svgroot = JSDot.helper.cesvg("svg"); // create element
	div.appendChild(this.svgroot);
	
	// gives size of the drawing, see svgFitSize
	div.setAttribute('style', 'height: 100%; width: 100%;');
	
	this.svgroot.setAttribute("id", divId+"_svg");
	this.svgroot.setAttribute("xmlns", JSDot.helper.svgns);
	this.svgroot.setAttribute("xmlns:xlink", JSDot.helper.xlinkns);
	
	/** View data associated to nodes. */
	this.nodeData = {};
	
	/** View data associated to edges. */
	this.edgeData = {};
	
	this.redrawAll();
	this.addHandler(); /* add listener to receive graph updates */
};

JSDot.View.prototype = {
	
	/** View identifier.
		Returns a string which can be used to build ids for DOM elements
		belonging to the view.
		@return {String} identifier
	*/
	getViewId: function() {
		//return 'jsdot-v'+this.divId;
		return this.divId;
	},
	
	/** Draw a node.
		@param {Node} n the node to draw
	*/
	drawNode: function(n){
		if (!n) return;
		
		/* get associated view data, if it doesn't exist create it */
		var nd = this.nodeData[n.name];
		if (!nd) {
			nd = {};
			this.nodeData[n.name] = nd;
		}
		
		/* create group for this node */
		var g = JSDot.helper.cesvg('g');
		g.jsdot_node = n;
		g.setAttribute('id', this.getViewId()+'+'+n.name);
		this.svgroot.appendChild(g);
		nd.group = g;
		
		/* resolve node stencil */
		nd.stencil = JSDot.stencils[n.stencil];
		if (!nd.stencil) {
			/* get a fallback */
			for (var i in JSDot.stencils) {
				nd.stencil = JSDot.stencils[i];
				break;
			}
		}
		
		/* draw the node */
		nd.stencil.draw(n, nd, g);
		nd.stencil.setPosition(n, nd);
		
		/* if it hasn't already been done, resolve label stencil name
		   to the actual stencil object */
		if (!nd.labelStencil) {
			nd.labelStencil = JSDot.node_label_stencils[n.label.type];
			if (!nd.labelStencil) {
				nd.labelStencil = JSDot.node_label_stencils['plain'];
			}
			n.label.value = n.label.value || ''; /* just make sure it is there */
		}
		nd.labelStencil.draw(n, nd, g);
		nd.labelStencil.setPosition(n, nd);
		
		/* now that the label has been drawn we can set the size of the node */
		nd.stencil.setSize(n, nd, nd.labelStencil.getSize(n, nd));
		
		this.svgFitSize();
	},
	
	/** Move node to a new position.
		Move the node without redrawing it, but must already have been drawn.
	*/
	updateNodePos: function(n) {
		var nd = this.nodeData[n.name];
		nd.stencil.setPosition(n, nd);
		nd.labelStencil.setPosition(n, nd);
		
		this.svgFitSize();
	},
	
	/** Draw a node and its edges.
		Draw a node and all edges it is connected to (both in- and out-bound).
		@param {Node_impl} n node to be drawn
	*/
	drawNodeWithEdges: function(n) {
		this.drawNode(n);
		for (var e in n.edges) {
			this.drawEdge(n.edges[e]);
		}
	},
	
	/** Remove a node from the drawing.
	@param {Node_impl} n node to remove
	*/
	removeNode: function(n) {
		var nd = this.nodeData[n.name];
		if (nd) {
			this.svgroot.removeChild(nd.group);
			delete this.nodeData[n.name];
		}
	},
	
	/** Draw an edge.
		@param {Edge} e the edge to draw
	*/
	drawEdge: function(e) {
		
		/* get associated view data, if it doesn't exist create it */
		var ed = this.edgeData[e.id];
		if (!ed) {
			ed = {};
			this.edgeData[e.id] = ed;
		}
		
		/* resolve edge stencil */
		ed.stencil = JSDot.edge_stencils[e.stencil];
		if (!ed.stencil) {
			/* get a fallback */
			for (var i in JSDot.edge_stencils) {
				ed.stencil = JSDot.edge_stencils[i];
				break;
			}
		}
		
		/* create a group for the edge */
		var g = JSDot.helper.cesvg('g');
		g.jsdot_edge = e;
		g.setAttribute('id', this.getViewId()+'+edge+'+e.id);
		this.svgroot.appendChild(g);
		ed.group = g;
		
		this.computeEdgePosition(e);
		
		/* draw the edge */
		ed.stencil.draw(e, ed, g);
		ed.stencil.setPosition(e, ed);
		
		/* draw label only if it exists */
		if (e.label) {
			/* if not already done resolve label stencil */
			if (!ed.labelStencil) {
				ed.labelStencil = JSDot.edge_label_stencils[e.label.type];
				if (!ed.labelStencil) {
					ed.labelStencil = JSDot.edge_label_stencils['plain'];
				}
				e.label.value = e.label.value || ''; /* just make sure it is there */
			}
			ed.labelStencil.draw(e, ed, g);
			ed.labelStencil.setPosition(e, ed);
		}
	},
	
	/** Move an edge.
		Updates an edge's position without completely redrawing it.
	*/
	updateEdgePos: function(e) {
		this.computeEdgePosition(e);
		var ed = this.edgeData[e.id];
		ed.stencil.setPosition(e, ed);
		if (e.label) ed.labelStencil.setPosition(e, ed);
	},
	
	/** Computes the position where the edge must be drawn.
		@private
		The position is stored as e.view.start and e.view.end
		and depends on the shape of the connected nodes.
		
		The drawing is not changed, use @link edge_stencil#setPosition for that.
		@param {Edge} e edge whose position must be updated
	*/
	computeEdgePosition: function(e) {
		var ed = this.edgeData[e.id];
		var srcD = this.nodeData[e.src.name];
		var dstD = this.nodeData[e.dst.name];
		ed.start = srcD.stencil.getBoundaryTo(e.src, srcD, e.dst.position);
		ed.end = dstD.stencil.getBoundaryTo(e.dst, dstD, e.src.position);
	},
	
	/** Remove an edge from the drawing.
	@param {Edge_impl} e edge to remove
	*/
	removeEdge: function(e) {
		var ed = this.edgeData[e.id];
		if (ed.group) {
			this.svgroot.removeChild(ed.group);
			delete this.edgeData[e.id];
		}
	},
	
	/** Redraw the whole graph.
		Remove all drawn nodes and edges and redraw the graph of the
		attached jsdot instance.
		
		Note: this will not erase the whole contentent of the svg,
		but only those elements for which the view has kept data.
		E.g. the svg defs for markers are left unchanged.
	*/
	redrawAll: function() {
		for (var i in this.edgeData) {
			this.svgroot.removeChild(this.edgeData[i].group);
		}
		for (var i in this.nodeData) {
			this.svgroot.removeChild(this.nodeData[i].group);
		}
		this.edgeData = {};
		this.nodeData = {};
		
		var ns = this.jsdot.graph.nodes;
		for (var i in ns) {
			this.drawNode(ns[i]);
		}
		ns = this.jsdot.graph.edges;
		for (var i in ns) {
			this.drawEdge(ns[i]);
		}
	},

	/** Bounding box of a node's shape.
		Bounding box contains 'height', 'width', 'x', 'y' and is relative to SVG.
		@param {JSDot.Node_impl} v Node
		@return {Object} bounding box
	*/
	getBBox: function(v) {
		if (v.isNode) {
			var d = this.nodeData[v.name];
			return d.stencil.getBBox(v, d);
		} else {
			return {'height': 0, 'width': 0, 'x': 0, 'y': 0 };
		}
	},
	
	/** Register handler needed by the view.
		Defines and registers the event handler that allows the view to receive
		model and selection updates notifications.
	*/
	addHandler: function() {
		var handler = {};
		var view = this;
		
		var selectionchgH = function(n, s) {
			var d;
			if (n.isNode) {
				d = view.nodeData[n.name];
			} else {
				d = view.edgeData[n.id];
			}
			d.stencil.highlight(n, d, s);
			d.highlight = s; /* needed to make highlighting survive a 'changed' event */
		};
		
		handler.created = function(n) {
			if (n.isEdge) {
				view.drawEdge(n);
			} else {
				view.drawNodeWithEdges(n);
			}
		};
		
		handler.removed = function(n) {
			if (n.isEdge) {
				view.removeEdge(n);
			} else {
				view.removeNode(n);
				for (e in n.edges) {
					view.removeEdge(n.edges[e]);
				}
			}
		};
		
		handler.moved = function(n) {
			if (n.isNode) { /* it is a node */
				view.updateNodePos(n);
				for (var i in n.edges) {
					view.updateEdgePos(n.edges[i]);
				}
			}
		};
		
		handler.changed = function(n) {
			if (n.isEdge) { /* edge */
				var sel = view.edgeData[n.id].highlight;
				view.removeEdge(n);
				view.drawEdge(n);
				if (sel) selectionchgH(n, sel);
			} else { /* node */
				var sel = view.nodeData[n.name].highlight;
				view.removeNode(n);
				view.drawNode(n);
				if (sel) selectionchgH(n, sel);
				/* edges do not need to be redrawn, just update them */
				for (i in n.edges) {
					view.updateEdgePos(n.edges[i]);
				}
			}
		};
		
		handler.newgraph = function() {
			view.redrawAll();
		};
		
		this.jsdot.addEventHandler(null, handler); /* graph events */
		this.jsdot.addEventHandler(this, 'selectionchg', selectionchgH);
	},
	
	/** DOM Element offset relative to document.
		@param {DOM Element} e
		@return {Array(left, top)} offsetLeft and offsetTop relative to document
	*/
	getOffset: function(e) {
		var l = 0, t = 0;
		do {
			l += e.offsetLeft;
			t += e.offsetTop;
			e = e.offsetParent;
		} while (e);
		return [l, t];
	},
	
	/** Accumulated scrolling offset of the parent nodes.
		@param {DOM Element} e
		@return {Array(left, top)} scroll offset
	*/
	getScrollOffset: function(e) {
		var l = 0, t = 0;
		/* we need to stop before the Document, since it doesn't have
		   any scroll* attribute.
		   But we take into account the html scroll, which is the outermost
		   scrollbar (the one for the whole page). */
		while ((e = e.parentNode).parentNode) {
			l += e.scrollLeft;
			t += e.scrollTop;
		}
		return [l, t];
	},
	
	/** Add relative coordinates to an event.
		Takes an event and add to it .relX and .relY which are the coordinates
		relative to this view.
		@param {DOM Event} evt event for which the relative coordinates are computed
	*/
	addRelCoord: function(evt) {
		/*
		var offset = this.getOffset(this.svgroot.parentNode);
		var scroll = this.getScrollOffset(this.svgroot.parentNode);
		evt.relX = evt.clientX - offset[0] + scroll[0];
		evt.relY = evt.clientY - offset[1] + scroll[1];
		//*/
		evt.relX = evt.layerX;
		evt.relY = evt.layerY;
	},
	
	/** Fire an event affecting this view.
		This is a shorthand to call {@link JSDot.jsdot_Impl.fireEvent} with this
		view as first argument.
		@see JSDot.jsdot_Impl.fireEvent
	*/
	fireViewEvent: function() {
		Array.prototype.unshift.call(arguments, this);
		return this.jsdot.fireEvent.apply(this.jsdot, arguments);
	},
	
	/** Add a class to the SVG element.
		This is needed because JQuery doesn't work on the svg.
		@param {String} klass class to add
	*/
	addClass: function(klass) {
		var c = (this.svgroot.getAttribute('class') || '').split(' ');
		if (c.indexOf(klass) < 0) {
			c.push(klass);
			this.svgroot.setAttribute('class', c.join(' '));
		}
	},
	
	/** Remove a class from the SVG element.
		This is needed because JQuery doesn't work on the svg.
		@param {String} klass class to remove
	*/
	removeClass: function(klass) {
		var c = (this.svgroot.getAttribute('class') || '').split(' ');
		var i = c.indexOf(klass);
		if (i < 0) return;
		c.splice(i, 1);
		this.svgroot.setAttribute('class', c.join(' '));
	},
	
	/** Adapt div size to svg size.
		Give to the parent div of the svg the size of the svg.
		This make the scrolling on the container working.
	*/
	svgFitSize: function() {
		var svgbb = this.svgroot.getBoundingClientRect();
		var cnt = this.container;
		var p = this.svgroot.parentNode;
		var pbb = p.getBoundingClientRect();
		
		var w = svgbb.left - pbb.left + svgbb.width;
		var h = svgbb.top - pbb.top + svgbb.height;
		
		w = Math.max(cnt.clientWidth-5, w);
		h = Math.max(cnt.clientHeight-10, h);
		p.style.width = w ? w + 'px' : '';
		p.style.height = h ? h + 'px' : '';
	},
	
	/** Return an instance of a tool for the current view.
		If 'params' exists, a reference to the graph and view will be added to it.
		@param {String} tool name of the tool
		@param {Object} params parameters passed to the tool's init function, if it exists
		@return {Object} the requested tool or null
	*/
	getTool: function(tool, params) {
		if (params) {
			params.graph = this.jsdot.graph;
			params.view = this;
		}
		return this.jsdot.getToolI('ViewTools', tool, params);
	},
	
};
/*
 This file is part of the JSDot library
 
 http://code.google.com/p/jsdot/
 
 Copyright (c) 2010 Carlo Vanini
 Copyright (c) 2009 Lucia Blondel, Nicos Giuliani, Carlo Vanini
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */

/** Construct a selection handler.
	@class Selection handler.
	Handles selection and dragging of nodes and edges in a view.

	@constructor
	@param {JSDot.jsdot_Impl} jsdot JSDot instance
	@param {JSDot.View} view JSDot view
*/
JSDot.Selection = function(jsdot, view) {

	/** Associated JSDot instance. */
	this.jsdot = jsdot;
	
	/** View on which the selection is represented. */
	this.view = view;
	
	/** Allow nodes to be selected.
		@note Be sure to call {@link deselectAll} when changing this to false.
	*/
	this.allowNodes = true;
	
	/** Allow edges to be selected.
		@note Be sure to call {@link deselectAll} when changing this to false.
	*/
	this.allowEdges = true;
	
	/** Allow multiple elements to be selected */
	this.allowMultiple = true;
	
	/** Allow dragging */
	this.allowDrag = true;
	
	/** Selected elements.
		Array of selected nodes and edges.
		@see select
		@see deselect
		@see deselectAll
	*/
	this.selection = [];
	
	/** True when dragging something
		@private
		@see svgMousemove_impl
	*/
	this.moving = false;
	
	/** Event which started a move.
		@private
	*/
	this.moveStart = null;
	
	/** Target object of an event.
		@private
		@see setEvtTarget
	*/
	this.evtTarget = null;
	
	/** Type of an event's target.
		@private
		@see setEvtTarget
	*/
	this.evtTargetType = '';


	/****************************************************************
		Register event listeners.
	****************************************************************/

	view.svgroot.addEventListener('mousedown',
			function(obj) {
				return function() {
					return obj.svgMousedown.apply(obj, arguments);
				};
			}(this), false);
	
	/** Handler for mousemove event on the SVG.
		Does dragging when it is enabled.
		
		We need to keep a reference to the handler in order to remove
		it when it is not needed anymore.
		
		The actual implementation is in {@link svgMousemove_impl},
		this is a closure.
		@see svgMousemove_impl
	*/
	this.svgMousemove =
			function(obj) {
				return function() {
					return obj.svgMousemove_impl.apply(obj, arguments);
				};
			}(this);
				
	view.svgroot.addEventListener('mouseup',
			function(obj) {
				return function() {
					return obj.svgMouseup.apply(obj, arguments);
				};
			}(this), false);
			
	jsdot.addEventHandler(jsdot.graph, 'removed',
			function(obj) {
				return function() {
					return obj.removedH.apply(obj, arguments);
				};
			}(this) );
			
	jsdot.addEventHandler(jsdot.graph, 'newgraph',
			function(obj) {
				return function() {
					return obj.newgraphH.apply(obj, arguments);
				};
			}(this) );
};

JSDot.Selection.prototype = {

	/** Handler for mousedown event on the SVG.
		Handles mousedown events.
		
		@private
	*/
	svgMousedown: function(evt) {

		/* prevent Firefox own drag & drop of the image */
		evt.preventDefault();

		this.moving = false;
		this.moveStart = evt;
		this.setEvtTarget(evt);
		if (this.allowDrag) {
			/* if dragging is enabled, register for mousemove */
			this.view.svgroot.addEventListener('mousemove', this.svgMousemove, false);
		};
		/* no matter whether it is a click or a drag, it will be handled in svgMouseup */
	},
	
	/** Find the target JSDot  element of an event.
		As a result {@link evtTarget} and {@link evtTargetType} are changed.
		@private
		@param {Object} evt event
	*/
	setEvtTarget: function(evt) {
		if (evt.target.tagName.toLowerCase() == 'svg') {
			/* background */
			this.evtTarget = null;
			this.evtTargetType = 's';
		} else {
			/* something contained in a group */
			var n = evt.target.parentNode.jsdot_node;
			if (n) {
				/* node */
				this.evtTarget = n;
				this.evtTargetType = 'n';
			} else if (n = evt.target.parentNode.jsdot_edge) {
				/* edge */
				this.evtTarget = n;
				this.evtTargetType = 'e';
			};
		};
	},
	
	/** Handle a click.
		When selection is enabled and it changes, the event
		'selectionchg' is fired. If selection is disabled
		then then a 'click' event is fired.<br>
		When only one of allowEdges and allowNodes
		is true, clicking on edge resp. node fires 'selectionchg'
		but clicking on the other one does nothing (no 'click').
		
		@note {@link setEvtTarget} must have been called before calling this!
		
		@private
		@param {Object} evt event
	*/
	handleClick: function(evt) {
		if (!this.allowEdges && !this.allowNodes) {
			/* If selection is disabled the event is 'click' */
			this.view.addRelCoord(evt);
			this.view.fireViewEvent('click', this.evtTarget, evt);
		} else {
			/* if selection is enabled we handle it */
			switch (this.evtTargetType) {
				case 's':
					/* click on background */
					this.deselectAll();
					break;
				case 'n':
				case 'e':
					/* node or edge */
					/* selection is allowed, so we (de)select */
					if (this.isSelected(this.evtTarget)) {
						if (evt.ctrlKey) {
							this.deselect(this.evtTarget);
						} else {
							this.deselectAll();
							this.select(this.evtTarget);
						}
					} else {
						if (!evt.ctrlKey) this.deselectAll();
						this.select(this.evtTarget);
					};
					break;
				default:
					/* ignore */
			};
		};
	},
	
	/** Implementation of the mousemove event handler.
		Does dragging when it is enabled.
		
		Use {@link svgMousemove} for add/remove listener.
		@private
	*/
	svgMousemove_impl: function(evt) {
		var dx = evt.pageX - this.moveStart.pageX;
		var dy = evt.pageY - this.moveStart.pageY;
		if (!this.moving) {
			/* We are not dragging yet. Check if the mouse moved more than
			   a given threshold, otherwise a mouseup would still be a click
			   instead of a drop.
			*/
			if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
				/* start moving */
				this.moving = true;
				this.view.fireViewEvent('pick', this.evtTarget);
			};
		};
		
		if (this.moving) {
			evt.dx = dx;
			evt.dy = dy;
			this.view.fireViewEvent('drag', this.evtTarget, evt);
		};
	},
	
	/** Handler for mouseup event on the SVG.
		@private
	*/
	svgMouseup: function(evt) {
		this.view.svgroot.removeEventListener('mousemove', this.svgMousemove, false);
		if (!this.moving) {
			this.handleClick(this.moveStart);
		} else {
			evt.dx = evt.pageX - this.moveStart.pageX;
			evt.dy = evt.pageY - this.moveStart.pageY;
			this.view.fireViewEvent('drop', this.evtTarget, evt);
		};
		this.moving = false;
		this.moveStart = null;
	},
	
	/** Handler for JSDot 'removed' event.
		When a node or an edge gets removed from the graph and it was
		selected, then it must be removed from the selection in order
		to keep it consistent.
		
		If an element is being removed it is implied that it won't be
		selected anymore, therefore no 'selectionchg' event is fired.
		@see doc_Handler.removed
	*/
	removedH: function(w) {
		if (w.isNode) {
			/* even if the node itself is not selected one of its edges
			   might be selected and must be removed */
			for (var e in w.edges) {
				this.deselect(w.edges[e], false);
				/* if it's not selected this doesn't do anything */
			}
		}
		this.deselect(w, false);
	},
	
	/** Handler for the {@link doc_Handler.newgraph} event.
		Clears the selection without firing any event.
	*/
	newgraphH: function() {
		this.selection.length = 0;
	},
	
	/** Adds an element to the selection.
		If the given element cannot be added to the
		selection it will be ignored.
		
		Fires a 'selectionchg' event.
		
		If the element is already selected does nothing.
		
		If the selection is not multiple, already selected
		elements will be deselected (firing the relative events).
		@param {Object} n @ref Node or @ref Edge to add
		@see allowNodes
		@see allowEdges
		@see allowMultiple
	*/
	select: function(n) {
		if (this.isSelected(n)) return;
		if (n.isEdge && this.allowEdges ||
				n.isNode && this.allowNodes) {
			/* it is an edge and we are allowed to select them,
			   or it is a node and they are allowed. */
			if (!this.allowMultiple) this.deselectAll();
			this.selection.push(n);
			this.view.fireViewEvent('selectionchg', n, true);
		};
	},
	
	/** Remove an element from selection.
		If the element is not selected this doesn't do anything.
		Fires a 'selectionchg' event.
		@param {Object} n the element (node/edge) to remove from selection
		@param {boolean} fire whether to fire the event or not, default is yes
		@see doc_Handler.selectionchg
	*/
	deselect: function(n, fire) {
		if (this.isSelected(n)) {
			this.selection.splice(this.selection.indexOf(n), 1);
			if (fire !== false) this.view.fireViewEvent('selectionchg', n, false);
		};
	},
	
	/** Deselect all nodes and edges.
		Fires a 'selectionchg' event for each node and edge.
	*/
	deselectAll: function() {
		var e;
		while (e = this.selection.pop()) {
			this.view.fireViewEvent('selectionchg', e, false);
			e = undefined;
		};
	},
	
	/** Check whether an element is selected.
		@param {Object} v Node or Edge to check
		@return {Boolean} True if v is selected, false otherwise
	*/
	isSelected: function (v) {
		return (this.selection.indexOf(v) >= 0);
	},
	
	/** First node in selection.
		Returns the first node in the selection, usually it is
		the first that has been selected.<br>
		Returns null if there isn't any selected node.
		@return {Node_impl} first selected node or null
	*/
	firstNode: function() {
		for (var i in this.selection) {
			if (this.selection[i].isNode) return this.selection[i];
		}
		return null;
	},
	
	/** Apply a function to selected node.
		For each selected node f(n) is called.
		f() must not change the selection!
	*/
	forNodes: function(f) {
		for (var i in this.selection) {
			if (this.selection[i].isNode) {
				f(this.selection[i]);
			}
		}
	},
	
	/** Apply a function to selected edges.
		For each selected edge f(n) is called.
		f() must not change the selection!
	*/
	forEdges: function(f) {
		for (var i in this.selection) {
			if (this.selection[i].isEdge) {
				f(this.selection[i]);
			}
		}
	},

};
/*
This file is part of the JSDot library

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/** @class Handler implementing drag&drop.
	@constructor
	@param {JSDot_impl} jsdot JSDot instance
	@param {jsdot_View} view view on which dragging should be visualised
	@param {jsdot_Selection} sel selection
*/
JSDot.Drag = function(jsdot, view, sel) {
	var h = this; /* the handler itself */
	
	this.nodes = null; /** nodes involved */
	this.edges = null; /** edges involved */

	/** Pick
		Populate {@link #nodes} and {@link #edges} with the nodes, rep. edges,
		involved in dragging.
	*/
	this.pick = function(obj) {
		h.nodes = [];
		h.edges = [];
		
		/* drag only nodes, and not background or edges */
		if (!obj || !obj.isNode) return;
		
		/* if the picked node is selected then drag selection, if not then
		   drag only the picked one */
		var s = [];
		if (!sel.isSelected(obj)) {
			// uncomment the following two lines to change selection to the dragged object
			//sel.deselectAll();
			//sel.select(obj);
			s = [obj];
		} else {
			s = sel.selection;
		}
		
		for (var i in s) {
			if (s[i].isNode) {
				/* it is a node, save initial position and append to list */
				view.nodeData[s[i].name].drag = s[i].position;
				h.nodes.push(s[i]);
				
				/* get the edges connected to it */
				var e = s[i].edges;
				for (var j in e) {
					if (!(e[j] in h.edges)) {
						h.edges.push(e[j]);
					}
				}
			}
		}
	};
	
	/** Drag
		Updates directly the view to give a feedback when dragging.
	*/
	this.drag = function(obj, evt) {
		for (var i in h.nodes) {
			var p = view.nodeData[h.nodes[i].name].drag;
			h.nodes[i].setPosition([p[0]+evt.dx, p[1]+evt.dy], false);
			view.updateNodePos(h.nodes[i]);
		}
		for (var i in h.edges) {
			view.updateEdgePos(h.edges[i]);
		}
	};
	
	/** Drop
		Make the move persistent if there is an editor.
	*/
	this.drop = function(obj, evt) {
		/* make sure the view is updated up to the last movement */
		for (i in h.nodes) {
			view.fireViewEvent('moved', h.nodes[i]);
		}
		h.nodes = [];
		h.edges = [];
	};
};
/*
This file is part of the JSDot library

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

JSDot.GraphTools.json = function() {
};

JSDot.GraphTools.json.prototype = {

	init: function(params) {
		if (!params || !params.graph) return null;
		this.graph = params.graph;
		return this;
	},

	importGraph: function(str) {
		var g = this.graph;
		var map = {};
		
		var obj = str;
		if (typeof str === 'string') {
			try { obj = JSON.parse(str); }
			catch (e) { return 1; }
		}
		if (!obj) return 1;
		
		g.setDefaultStencils(obj.defaultNodeStencil, obj.defaultEdgeStencil);
		if (typeof obj.nodes != "object" || typeof obj.edges != "object") {
			return 1; // obj is malformed
		}
		
		for (var i in obj.nodes) {
			var t = obj.nodes[i];
			if (map[t.name]) return 2; // duplicate name in obj
			var c = g.createNode(t.name, false);
			if (!c) {
				c = g.createNode(null, false);
			}
			map[t.name] = c;
			if (t.label) c.setLabel(t.label.value, false);
			if (t.position) c.setPosition(t.position, false);
			if (typeof t.stencil == "string") c.setStencil(t.stencil, false);
			if (t.userData && t.userData["data"]) c.setData("data", t.userData["data"]);
		}
		
		for (var i in obj.edges) {
			var t = obj.edges[i];
			if (!map[t.src] || !map[t.dst]) return 3; // edge links inexistent node
			var c = g.createEdge(map[t.src], map[t.dst], false);
			if (t.label) c.setLabel(t.label.value, false);
			if (typeof t.stencil == "string") c.setStencil(t.stencil, false);
			if (t.userData && t.userData["data"]) c.setData("data", t.userData["data"]);
		}
		
		this.graph.fireGraphEvent('newgraph');
		return 0;
	},
	
	exportGraph: function() {
		var res = {
			nodes: [],
			edges: [],
			defaultNodeStencil: this.graph.defaultNodeStencil,
			defaultEdgeStencil: this.graph.defaultEdgeStencil,
		};
		var l = this.graph.nodes;
		for (var i in l) {
			var n = l[i];
			res.nodes.push({
				name: n.name,
				label: n.label,
				position: n.position,
				stencil: n.stencil,
				userData: n.userData
			});
		}
		l = this.graph.edges;
		for (var i in l) {
			var n = l[i];
			res.edges.push({
				src: n.src.name,
				dst: n.dst.name,
				label: n.label,
				stencil: n.stencil,
				userData: n.userData
			});
		}
		return JSON.stringify(res);
	},
	
};
/*
This file is part of the JSDot library

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

JSDot.ViewTools.Layout.Center = function() {
};

JSDot.ViewTools.Layout.Center.prototype = {

	init: function(params) {
		this.view = params.view;
		this.graph = params.graph;
		return true;
	},
	
	doLayout: function() {
		
		var nd = this.graph.nodes;
		var xmin = 0, ymin = 0, xmax = 0, ymax = 0;
		for(var i in nd) {
			var p = nd[i].position;
			xmin = xmax = p[0];
			ymin = ymax = p[1];
			break;
		}
		
		for (var i in nd) {
			var p = nd[i].position;
			var bb = this.view.getBBox(nd[i]);
			xmin = Math.min(xmin, bb.x);
			xmax = Math.max(xmax, bb.x+bb.width);
			ymin = Math.min(ymin, bb.y);
			ymax = Math.max(ymax, bb.y+bb.height);
		}
		
		var svgbb = this.view.svgroot.parentNode.getBoundingClientRect();
		//var svgbb = this.view.svgroot.getBoundingClientRect();
		var rx = Math.min(1, svgbb.width / (xmax - xmin));
		var ry = Math.min(1, svgbb.height / (ymax - ymin));
		var dx = 0;
		var dy = 0;
		if (rx != 1) {
			dx = -xmin;
		} else {
			/* we didn't resize, it means the drawing is not bigger than the available space */
			/* we move only if there is something outside the visible region */
			if (xmin < 0) dx = -xmin;
			else if (xmax > svgbb.width) dx = svgbb.width - xmax;
			/* use the line below to always center */
			//dx = -xmin + (svgbb.width - (xmax-xmin)) / 2;
		}
		if (ry != 1) {
			dy = -ymin;
		} else {
			if (ymin < 0) dy = -ymin;
			else if (ymax > svgbb.height) dy = svgbb.height - ymax;
			//dy = -ymin + (svgbb.height - (ymax-ymin)) / 2;
		}
		
		for (var i in nd) {
			var p = nd[i].position;
			nd[i].setPosition( [(p[0]+dx)*rx, (p[1]+dy)*ry] );
		}
	},

};
/*
This file is part of the JSDot library

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

JSDot.ViewTools.Layout.SpringEmbedder = function() {

	this.options = {
		nodesep: 20,
		iterations: 20,
	};

};

JSDot.ViewTools.Layout.SpringEmbedder.prototype = {

	init: function(params) {
		this.view = params.view;
		this.graph = params.graph;
		return true;
	},
	
	doLayout: function() {
	
		/* where we keep our information about nodes */
		this.nodes = {};
		
		/* info about edges */
		this.edges = {};
		
		/* get bounding box for every node */
		var nd = this.graph.nodes;
		for (var i in nd) {
			var p = nd[i].position;
			this.nodes[i] = {
				bb: this.view.getBBox(nd[i]),
				x: p[0],
				y: p[1],
				accelx: 0,
				accely: 0,
				node: nd[i]
				};
		}
		
		var ed = this.graph.edges;
		for (var i in ed) {
			var sbb = this.nodes[ed[i].src.name].bb;
			var dbb = this.nodes[ed[i].dst.name].bb;
			this.edges[i] = {
				edgelen: Math.max(sbb.width, sbb.height) +
					Math.max(dbb.width, dbb.height) + this.options.nodesep,
				src: this.nodes[ed[i].src.name],
				dst: this.nodes[ed[i].dst.name]
			};
		}
		
		for (var i = this.options.iterations; i > 0; i--) {
			this.springEmbedder(); /* do one step */
		}
		
		this.updateRealNodes();
		
		delete this.nodes;
		delete this.edges;
		
		/* not connected nodes tend to fly off, so we scale and center */
		this.view.getTool('Layout.Center', {}).doLayout();
	
	},
	
	updateRealNodes: function() {
		var nd = this.nodes;
		for (var i in nd) {
			var n = nd[i];
			n.node.setPosition( [n.x, n.y] );
		}
	},
	
	springEmbedder: function() {
	
		/* calculate springs forces */
		var ed = this.edges;
		for (var i in ed) {
			var vx = ed[i].dst.x - ed[i].src.x;
			var vy = ed[i].dst.y - ed[i].src.y;
			var len = Math.sqrt(vx*vx + vy*vy);
			if (len == 0) len = this.options.nodesep;
			var f = (ed[i].edgelen - len) / (len * 3);
			var dx = f * vx;
			var dy = f * vy;
			
			ed[i].src.accelx -= dx;
			ed[i].src.accely -= dy;
			ed[i].dst.accelx += dx;
			ed[i].dst.accely += dy;
		}
		
		/* calculate node repulsion forces */
		var nd = this.nodes;
		for (var i in nd) {
			var n1 = nd[i];
			var dx = 0;
			var dy = 0;
			
			for (var j in nd) {
				if (i != j) { /* skip same node */
					var n2 = nd[j];
					var vx = n1.x - n2.x;
					var vy = n1.y - n2.y;
					var len = Math.sqrt(vx*vx + vy*vy);
					//var len = vx*vx + vy*vy;
					if (len == 0) {
						dx += Math.random();
						dy += Math.random();
					} else {
						dx += vx / len;
						dy += vy / len;
					}
				}
			}
			
			var dlen = dx*dx + dy*dy;
			if (dlen > 0) { /* might be 0... wath's wrong? */
				dlen = Math.sqrt(dlen)/2;
				n1.accelx += dx * dlen;
				n1.accely += dy * dlen;
			}
		}
		
		/* calculate new positions */
		for (var i in nd) {
			var n1 = nd[i];
			n1.x += n1.accelx * 0.1;
			n1.y += n1.accely * 0.1;
			n1.accelx = n1.accelx / 2;
			n1.accely = n1.accely / 2;
		}
		
	},

};
/*
This file is part of the JSDot library

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini
Copyright (c) 2009 Lucia Blondel, Nicos Giuliani, Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/** @class Handler visualizing the creation of an edge.
	<br>This handler keeps track of the first clicked node,
	then draws the line to visualize the edge being created,
	and actually creates the edge when the second node is clicked.
	@constuctor
	@param {JSDot.jsdot_Impl} jsdot jsdot instance
	@param {JSDot.View} view view where we are drawing
	@param {JSDot.Editor} editor (optional) null or editor specifying the stencil
*/
JSDot.EdgeViz = function(jsdot, view, editor) {
	
	var my = this; /* closure for handlers */
	
	/** Starting node for the edge. */
	this.start = null;
	
	this.jsdot = jsdot;
	
	this.view = view;
	
	this.editor = editor;
	
	/** SVG line drawn on the view */
	this.line = null;
	
	/** The registered mousemove listener. */
	this.moveH = null;
	
	/** Registered handler for cancelling drawing (escape key). */
	this.cancelH = null;
	
	/** Handler for the JSDot click event. */
	this.click = function(obj, evt) {
	
		/* if it's not a node do nothing */
		if (!obj || !obj.isNode) return;
		
		/* selection of first node */
		if (!my.start) {
			my.start = obj;
			my.line = JSDot.helper.cesvg('line');
			my.line.setAttribute('class', 'jsdot_edgeviz_line');
			my.view.svgroot.appendChild(my.line);
			my.line.setAttribute('x1', evt.relX);
			my.line.setAttribute('y1', evt.relY);
			my.line.setAttribute('x2', evt.relX);
			my.line.setAttribute('y2', evt.relY);
			my.moveH = my.mousemove(my.view, my.line);
			my.view.svgroot.addEventListener('mousemove', my.moveH, false);
			my.cancelH = function(o) { return function(e) { if (e.keyCode == 27) o.cancel(); }; }(my);
			document.addEventListener('keydown', my.cancelH, false);
			window.focus();
			return;
		}
		
		/* selection of second node */
		
		var e = my.jsdot.graph.createEdge(my.start, obj, false);
		if (my.editor) e.setStencil(my.editor.currentEdgeStencil, false);
		my.cancel(); /* remove line and handlers */
		my.jsdot.fireEvent(my.jsdot.graph, 'created', e);
	};
	
	/** Creates the mousemove handler. */
	this.mousemove = function(view, line) {
		return function(evt) {
			view.addRelCoord(evt);
			line.setAttribute('x2', evt.relX);
			line.setAttribute('y2', evt.relY);
		};
	};
	
	/** Stop drawing. */
	this.cancel = function() {
		if (my.moveH) my.view.svgroot.removeEventListener('mousemove', my.moveH, false);
		if (my.cancelH) document.removeEventListener('keydown', my.cancelH, false);
		if (my.line) my.view.svgroot.removeChild(my.line);
		my.moveH = null;
		my.cancelH = null;
		my.line = null;
		my.start = null;
	};

};
/*
 This file is part of the JSDot library
 
 http://code.google.com/p/jsdot/
 
 Copyright (c) 2010 Carlo Vanini
 Copyright (c) 2009 Lucia Blondel, Nicos Giuliani, Carlo Vanini
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */

/**
	Construct a JSDot Editor.
	@class JSDot editor.
	@constructor
*/
JSDot.Editor = function(jsdot, view, sel) {

	/** Associated JSDot instance. */
	this.jsdot = jsdot;
	
	/** Associated view. */
	this.view = view;
	
	/** Selection on the view. */
	this.selection = sel;

	/** Toolbar container.
		Div element containig the toolbar elements.
		@type {DOM Element}
	*/
	this.tbContainer = null;

	/** Current node stencil name.
		The stencil that will be given to the new noded created by this editor.<br>
		Note that this is the name of a stencil in {@link JSDot.stencils} and not
		the stencil itself.
		@type String
	*/
	this.currentNodeStencil = null;
	
	/** Current edge stencil name.
		The stencil that will be given to the new edges created by this editor.<br>
		Note that this is the name of a stencil in {@link JSDot.edge_stencils} and not
		the stencil itself.
		@type String
	*/
	this.currentEdgeStencil = null;
	
	/** Instance of the dialog.
		Instance of {@link JSDot.Editor.EditDialog} created by
		{@link JSDot.Editor} constructor.
	*/
	this.editDialog = null;
	
	/** The nested bar currently shown */
	this.activeNested = null;
	
	/** List of registered nested bars. */
	this.nestedBars = {};
	
	
	/* create toolbar container */
	var tb = document.createElement('div');
	tb.setAttribute('class', 'ui-widget-header ui-corner-all jsdot-toolbar');
	document.body.appendChild(tb);
	this.tbContainer = tb;
	
	/* set toolbar's initial position */
	var offset = view.getOffset(view.container);
	if (offset[1] > 25) offset[1] -= 25;
	tb.style.top = offset[1] + 'px';
	tb.style.left = offset[0] + 'px';
	
	for (var i in JSDot.stencils) { this.currentNodeStencil = i; break; };
	for (var i in JSDot.edge_stencils) { this.currentEdgeStencil = i; break; };
	new JSDot.Editor.MainBar(this, tb);
	this.editDialog = new JSDot.Editor.EditDialog(this);
};

JSDot.Editor.prototype = {

	/** Set selected button.
		Change tool icon highlighting to show which button is selected
		inside a given toolbar. If another one was already selected,
		it will be deselected.<br>
		If a function 'onDeselect' is defined on the button being deselected,
		it will be called.
		@param {Object} tb the toolbar
		@param {Object} b the button
	*/
	setSelected: function(tb, b) {
		if (tb.selected) {
			if (tb.selected.onDeselect) tb.selected.onDeselect();
			$(tb.selected).removeClass('jsdot-tb-selected');
		}
		$(b).addClass('jsdot-tb-selected');
		tb.selected = b;
	},

	/** Register a new nested bar. */
	addNestedBar: function(bar) {
		this.nestedBars[bar.name] = bar;
		$(bar.container).addClass('ui-widget ui-corner-all jsdot-tb-nested jsdot-tb-hiddentb');
		this.tbContainer.appendChild(bar.container);
	},
	
	/** Show a registered nested bar. */
	showNestedBar: function(name) {
		this.hideNestedBar();
		if (this.nestedBars[name]) $(this.nestedBars[name].container).removeClass('jsdot-tb-hiddentb');
		this.activeNested = this.nestedBars[name];
	},
	
	/** Hides the currently active nested bar. */
	hideNestedBar: function() {
		if (this.activeNested) $(this.activeNested.container).addClass('jsdot-tb-hiddentb');
		this.activeNested = null;
	},
	
	/** Return an instance of a tool for the current editor.
		If 'params' exists, a reference to the graph, view and editor will be added to it.
		@param {String} tool name of the tool
		@param {Object} params parameters passed to the tool's init function, if it exists
		@return {Object} the requested tool or null
	*/
	getTool: function(tool, params) {
		if (params) {
			params.graph = this.jsdot.graph;
			params.view = this.view;
			params.editor = this;
		}
		return this.jsdot.getToolI('EditTools', tool, params);
	},
};

/** @class Main toolbar.
	@creator
	Create the toolbar iside the editor.
	@param {jsdot_Editor} editor
	@param {Object} p parent DOM element where to insert button elements
*/
JSDot.Editor.MainBar = function(editor, p) {
	var tb = this; // no need for closure actually, but use as shorthand
	
	/** Attached editor.
		Editor to which this toolbar is attached.
		@type JSDot.Editor
	*/
	this.editor = editor;
	
	/** Handler for drag&drop.
		@type JSDot.Drag
	*/
	this.dragH = new JSDot.Drag(editor.jsdot, editor.view, editor.selection);
	
	/** Handler for creating nodes.
		@type function
		@see createNodeH_T
	*/
	this.createNodeH = this.createNodeH_T(editor.jsdot);
	
	/** Handler for creating edges.
		@type JSDot.EdgeViz
	*/
	this.createEdgeH = new JSDot.EdgeViz(editor.jsdot, editor.view, editor);
	
	/** Handler for removing nodes and edges
		@type function
		@see removeH_T
	*/
	this.removeH = this.removeH_T(editor.jsdot);
	
	/** Nested bar for layout operations.
		@type JSDot.Editor.LayoutBar
	*/
	this.layoutBar = new JSDot.Editor.LayoutBar(editor);
	
	/** Nested bar for creating nodes.
		@type JSDot.Editor.CreateNodeBar
	*/
	this.createNodeBar = new JSDot.Editor.CreateNodeBar(editor);
	
	/** Nested bar for creating edges.
		@type JSDot.Editor.CreateEdgeBar
	*/
	this.createEdgeBar = new JSDot.Editor.CreateEdgeBar(editor);

	/** Selected tool.
		This is used to keep track of which tool icon is highlighted.
		@see JSDot.Editor.setSelected
	*/
	this.selected = null;
	
	
	/****************************************************************
		Now create the UI part of the toolbar.
	****************************************************************/
	
	var spc = document.createElement('div');
	spc.setAttribute('class', 'jsdot-tb-handleL');
	p.appendChild(spc);
	spc = document.createElement('div');
	spc.setAttribute('class', 'jsdot-tb-handleR');
	p.appendChild(spc);
	$(p).draggable({ handle: '.jsdot-tb-handle' });
	
	var main = document.createElement('div');
	main.setAttribute('class', 'jsdot-tb-main');
	p.appendChild(main);
	
	var btnSel = document.createElement('button');
	btnSel.innerHTML = 'Select';
	main.appendChild(btnSel);
	$(btnSel).button({
		text: false,
		icons: { primary: 'jsdot-icon jsdot-icon-cursor' }
	})
	.click(function() {
		editor.setSelected(tb, btnSel);
		editor.jsdot.addEventHandler(editor.view, tb.dragH);
		var s = editor.selection;
		s.allowNodes = true;
		s.allowEdges = true;
		s.allowMultiple = true;
		s.allowDrag = true;
		editor.showNestedBar('layout');
	});
	btnSel.onDeselect = function() {
		editor.jsdot.removeEventHandler(editor.view, tb.dragH);
		editor.hideNestedBar('layout');
	};
	
	var btnAddN = document.createElement('button');
	btnAddN.innerHTML = 'Add node';
	main.appendChild(btnAddN);
	$(btnAddN).button({
		text: false,
		icons: { primary: 'jsdot-icon jsdot-icon-addnode' }
	})
	.click(function() {
		editor.setSelected(tb, btnAddN);
		var s = editor.selection;
		s.allowNodes = false;
		s.allowEdges = false;
		s.allowMultiple = false;
		s.allowDrag = false;
		s.deselectAll();
		editor.jsdot.addEventHandler(editor.view, 'click', tb.createNodeH);
		editor.showNestedBar('createnode');
		editor.view.addClass('jsdot-cursor-addnode');
	});
	btnAddN.onDeselect = function() {
		editor.jsdot.removeEventHandler(editor.view, 'click', tb.createNodeH);
		editor.hideNestedBar('createnode');
		editor.view.removeClass('jsdot-cursor-addnode');
	};
	
	var btnAddE = document.createElement('button');
	btnAddE.innerHTML = 'Add edge';
	main.appendChild(btnAddE);
	$(btnAddE).button({
		text: false,
		icons: { primary: 'jsdot-icon jsdot-icon-addedge' }
	})
	.click(function() {
		editor.setSelected(tb, btnAddE);
		var s = editor.selection;
		s.allowNodes = false;
		s.allowEdges = false;
		s.allowMultiple = false;
		s.allowDrag = false;
		s.deselectAll();
		editor.jsdot.addEventHandler(editor.view, tb.createEdgeH);
		editor.showNestedBar('createedge');
		editor.view.addClass('jsdot-cursor-addedge');
	});
	btnAddE.onDeselect = function() {
		editor.jsdot.removeEventHandler(editor.view, tb.createEdgeH);
		tb.createEdgeH.cancel(); /* stop if you were drawing */
		editor.hideNestedBar('createedge');
		editor.view.removeClass('jsdot-cursor-addedge');
	};
	
	var btnRm = document.createElement('button');
	btnRm.innerHTML = 'Remove node';
	main.appendChild(btnRm);
	$(btnRm).button({
		text: false,
		icons: { primary: 'jsdot-icon jsdot-icon-removenode' }
	})
	.click(function() {
		var s = editor.selection;
		if (s.selection.length > 0) {
			/* something is selected, then delete selection */
			/* we need a copy of the selection, since it will change while
			   we iterate on it */
			var l = [];
			s.forNodes(function(n) { l.push(n); });
			for (var i in l) { editor.jsdot.graph.removeNode(l[i]); };
			l = [];
			s.forEdges(function(e) { l.push(e); });
			for (var i in l) { editor.jsdot.graph.removeEdge(l[i]); };
		} else {
			/* noting selected, then switch to delete tool */
			editor.setSelected(tb, btnRm);
			s.allowNodes = false;
			s.allowEdges = false;
			s.allowMultiple = false;
			s.allowDrag = false;
			editor.jsdot.addEventHandler(editor.view, 'click', tb.removeH);
			editor.view.addClass('jsdot-cursor-removenode');
		}
	});
	btnRm.onDeselect = function() {
		editor.jsdot.removeEventHandler(editor.view, 'click', tb.removeH);
		editor.view.removeClass('jsdot-cursor-removenode');
	};
	
	var btnED = document.createElement('button');
	btnED.innerHTML = 'Edit properties';
	main.appendChild(btnED);
	$(btnED).button({
		text: false,
		icons: { primary: 'jsdot-icon jsdot-icon-editdialog' }
	})
	.click(function() {
		editor.editDialog.toggleOpen();
	});
	
	editor.addNestedBar(this.layoutBar);
	editor.addNestedBar(this.createNodeBar);
	editor.addNestedBar(this.createEdgeBar);
	btnSel.click(); // selection tool is enabled on startup
};

JSDot.Editor.MainBar.prototype = {

	/** Construct handler for creating nodes.
		@param {JSDot.jsdot_Impl} jsdot jsdot instance
		@return {function} handler
	*/
	createNodeH_T: function(jsdot) {
		var editor = this.editor;
		return function(obj, evt) {
				var n = jsdot.graph.createNode(null, false);
				n.setPosition([evt.relX, evt.relY], false);
				if (editor.currentNodeStencil) n.setStencil(editor.currentNodeStencil, false);
				jsdot.fireEvent(jsdot.graph, 'created', n);
			};
	},
	
	/** Construct handler for removing nodes and edges.
		@param {jsdot_Impl} jsdot jsdot instance
		@return {function} handler
	*/
	removeH_T: function(jsdot) {
		return function(obj, evt) {
				if (obj && obj.isNode) { /* node */
					jsdot.graph.removeNode(obj);
				} else if (obj && obj.isEdge) { /* edge */
					jsdot.graph.removeEdge(obj);
				}
			};
	},

};

/** @class Layout toolbar.
	@constructor
	@param {jsdot_Editor} editor
	@param {Object} p parent DOM element where to insert button elements
*/
JSDot.Editor.LayoutBar = function(editor) {
	var d = document.createElement('div');
	
	// mandatory fields for nested bars
	this.name = 'layout';
	this.container = d;
	
	var btnL = document.createElement('button');
	btnL.innerHTML = 'Align left';
	d.appendChild(btnL);
	$(btnL).button({
		text: false,
		icons: { primary: 'jsdot-icon jsdot-icon-alignleft' }
	})
	.click(this.leftH(editor));
	
	var btnC = document.createElement('button');
	btnC.innerHTML = 'Center';
	d.appendChild(btnC);
	$(btnC).button({
		text: false,
		icons: { primary: 'jsdot-icon jsdot-icon-aligncenter' }
	})
	.click(this.centerH(editor));
	
	var btnR = document.createElement('button');
	btnR.innerHTML = 'Align right';
	d.appendChild(btnR);
	$(btnR).button({
		text: false,
		icons: { primary: 'jsdot-icon jsdot-icon-alignright' }
	})
	.click(this.rightH(editor));
	
	var btnT = document.createElement('button');
	btnT.innerHTML = 'Align top';
	d.appendChild(btnT);
	$(btnT).button({
		text: false,
		icons: { primary: 'jsdot-icon jsdot-icon-aligntop' }
	})
	.click(this.topH(editor));
	
	var btnVC = document.createElement('button');
	btnVC.innerHTML = 'Center vertically';
	d.appendChild(btnVC);
	$(btnVC).button({
		text: false,
		icons: { primary: 'jsdot-icon jsdot-icon-alignvcenter' }
	})
	.click(this.vcenterH(editor));
	
	var btnB = document.createElement('button');
	btnB.innerHTML = 'Align bottom';
	d.appendChild(btnB);
	$(btnB).button({
		text: false,
		icons: { primary: 'jsdot-icon jsdot-icon-alignbottom' }
	})
	.click(this.bottomH(editor));
};

JSDot.Editor.LayoutBar.prototype = {

	leftH: function(editor) {
		return function() {
			var s = editor.selection;
			var v = editor.view;
			/* find first node and initialize l */
			var n = s.firstNode();
			if (!n) return;
			var l = v.getBBox(n).x;
			
			/* find leftmost node */
			s.forNodes(function(n) {
				var p = v.getBBox(n).x;
				if (p < l) l = p;
			});
			
			/* update nodes */
			s.forNodes(function(n) {
				n.setPosition([ l + v.getBBox(n).width/2, n.position[1] ]);
			});
		};
	},

	centerH: function(editor) {
		return function() {
			var s = editor.selection;
			/* find first node and initialize l and r */
			var n = s.firstNode();
			if (!n) return;
			var l = n.position[0];
			var r = l;
			
			/* find the middle */
			s.forNodes(function(n) {
				if (n.position[0] < l) l = n.position[0];
				if (n.position[0] > r) r = n.position[0];
			});
			l = l + (r-l)/2;
			
			/* update nodes */
			s.forNodes(function(n) {
				n.setPosition([ l, n.position[1] ]);
			});
		};
	},

	rightH: function(editor) {
		return function() {
			var s = editor.selection;
			var v = editor.view;
			/* find first node and initialize r */
			var n = s.firstNode();
			if (!n) return;
			var p = v.getBBox(n);
			var r = p.x + p.width;
			
			/* find rightmost node */
			s.forNodes(function(n) {
				p = v.getBBox(n);
				p = p.x + p.width;
				if (p > r) r = p;
			});
			
			/* update nodes */
			s.forNodes(function(n) {
				n.setPosition([ r - v.getBBox(n).width/2, n.position[1] ]);
			});
		};
	},

	topH: function(editor) {
		return function() {
			var s = editor.selection;
			var v = editor.view;
			/* find first node and initialize y */
			var n = s.firstNode();
			if (!n) return;
			var y = v.getBBox(n).y;
			
			/* find topmost node */
			s.forNodes(function(n) {
				var p = v.getBBox(n).y;
				if (p < y) y = p;
			});
			
			/* update nodes */
			s.forNodes(function(n) {
				n.setPosition([ n.position[0], y + v.getBBox(n).height/2 ]);
			});
		};
	},

	vcenterH: function(editor) {
		return function() {
			var s = editor.selection;
			/* find first node and initialize top and btm */
			var n = s.firstNode();
			if (!n) return;
			var top = n.position[1];
			var btm = top;
			
			/* find center */
			s.forNodes(function(n) {
				if (n.position[1] < top) top = n.position[1];
				if (n.position[1] > btm) btm = n.position[1];
			});
			top += (btm-top)/2;
			
			/* update nodes */
			s.forNodes(function(n) {
				n.setPosition([ n.position[0], top ]);
			});
		};
	},

	bottomH: function(editor) {
		return function() {
			var s = editor.selection;
			var v = editor.view;
			/* find first node and initialize y */
			var n = s.firstNode();
			if (!n) return;
			var p = v.getBBox(n);
			var y = p.y + p.height;
			
			/* find bottom node */
			s.forNodes(function(n) {
				p = v.getBBox(n);
				p = p.y + p.height;
				if (p > y) y = p;
			});
			
			/* update nodes */
			s.forNodes(function(n) {
				n.setPosition([ n.position[0], y - v.getBBox(n).height/2 ]);
			});
		};
	},
};

/** @class Node creation toolbar.
	Allows to select a stencil for the new nodes that will be created.
	@constructor
	@param {jsdot_Editor} editor
*/
JSDot.Editor.CreateNodeBar = function(editor) {
	var d = document.createElement('div');
	
	// mandatory fields for nested bars
	this.name = 'createnode';
	this.container = d;
	
	var stc = document.createElement('select');
	for (var i in JSDot.stencils) {
		stc.add(new Option(i, i, i == editor.currentNodeStencil), null);
	}
	d.appendChild(stc);
	
	stc.addEventListener('change', function() {
		editor.currentNodeStencil = this.value;
		}, false);

};

/** @class Edge creation toolbar.
	Allows to select a stencil for the new edge that will be created.
	@constructor
	@param {jsdot_Editor} editor
*/
JSDot.Editor.CreateEdgeBar = function(editor) {
	var d = document.createElement('div');
	
	// mandatory fields for nested bars
	this.name = 'createedge';
	this.container = d;
	
	var stc = document.createElement('select');
	for (var i in JSDot.edge_stencils) {
		stc.add(new Option(i, i, i == editor.currentEdgeStencil), null);
	}
	d.appendChild(stc);
	
	stc.addEventListener('change', function() {
		editor.currentEdgeStencil = this.value;
		}, false);

};

/** @class Editing dialog.
	This dialog allows to view and change properties like label text and stencil
	of existing elements.
	@constructor
	@param {jsdot_Editor} editor
*/
JSDot.Editor.EditDialog = function(editor) {

	/* insert html part of the dialog */
	var dialog = document.createElement('div');
	editor.view.container.appendChild(dialog);
	$(dialog).dialog({ autoOpen: false, closeOnEscape: false,
			position: 'right', dialogClass: 'jsdot-editdialog' });
			
	var accordion = document.createElement('div');
	accordion.setAttribute('class',
		'ui-accordion ui-widget ui-helper-reset ui-accordion-icons');
	accordion.setAttribute('role', 'tablist');
	dialog.appendChild(accordion);
			
	/** Add a new section to the edit dialog. */
	function addSection(name, options) {
		var header = document.createElement('h3');
		header.appendChild(document.createTextNode(name));
		header.setAttribute('class',
			'ui-accordion-header ui-helper-reset ui-state-default ui-corner-all');
		header.setAttribute('role', 'tab');
		accordion.appendChild(header);
		var content = document.createElement('div');
		content.setAttribute('class',
			'ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom');
		content.setAttribute('role', 'tabpanel');
		accordion.appendChild(content);
		$(header).click(function () {
				$(content).toggleClass('ui-accordion-content-active');
				$(header).toggleClass('ui-corner-all ui-corner-top');
				//$(content).toggle('normal');
			});
			
		if (options && options.expanded) {
			$(header).click();
		}
		
		return {
			'name': name,
			'header': header,
			'content': content
		};
	};
	
	/*********************/
	/* Selection section */
	/*********************/
	var selection = addSection('Selection', {'expanded': true}).content;
	
	var msg = document.createElement('p');
	msg.innerHTML = 'edit dialog';
	selection.appendChild(msg);
	
	var nodeForm = document.createElement('div');
	selection.appendChild(nodeForm);
	var nodeFStcl = document.createElement('select');
	nodeForm.appendChild(nodeFStcl);
	nodeFStcl.addEventListener('change', function() {
			var n = editor.selection.selection[0];
			n.setStencil(this.value);
			}, false);
	var nodeFLabel = document.createElement('input');
	nodeForm.appendChild(nodeFLabel);
	nodeFLabel.addEventListener('keypress', function(evt) {
			switch(evt.keyCode) {
				case 27: /* escape */
					handler.selectionchg(); /* reload values in dialog */
					break;
				case 13: /* enter */
					var n = editor.selection.selection[0];
					n.setLabel(this.value);
					break;
			} }, false);

	var nodeFAttribsJSON = document.createElement('textarea');
	nodeForm.appendChild(nodeFAttribsJSON);
	nodeFAttribsJSON.addEventListener('keypress', function(evt) {
			switch(evt.keyCode) {
				case 27: /* escape */
					handler.selectionchg(); /* reload values in dialog */
					break;
				case 13: /* enter */
					//alert(this.value);
					var n = editor.selection.selection[0];
					n.setData("data", this.value);
					break;
			} }, false);


	
	
	var edgeForm = document.createElement('div');
	selection.appendChild(edgeForm);
	var edgeFStcl = document.createElement('select');
	edgeForm.appendChild(edgeFStcl);
	edgeFStcl.addEventListener('change', function() {
			var n = editor.selection.selection[0];
			n.setStencil(this.value);
			}, false);
	var edgeFLabel = document.createElement('input');
	edgeForm.appendChild(edgeFLabel);
	edgeFLabel.addEventListener('keypress', function(evt) {
			switch(evt.keyCode) {
				case 27: /* escape */
					handler.selectionchg(); /* reload values in dialog */
					break;
				case 13: /* enter */
					var n = editor.selection.selection[0];
					n.setLabel(this.value);
					break;
			} }, false);

	var edgeFAttribsCondition = document.createElement('textarea');
	edgeForm.appendChild(edgeFAttribsCondition);
	edgeFAttribsCondition.addEventListener('keypress', function(evt) {
			switch(evt.keyCode) {
				case 27: /* escape */
					handler.selectionchg(); /* reload values in dialog */
					break;
				case 13: /* enter */
					//alert(this.value);
					var n = editor.selection.selection[0];
					n.setData("data", this.value);
					break;
			} }, false);


	/******************/
	/* Layout section */
	/******************/
	var layout = addSection('Layout', {'expanded': false}).content;
	var layoutSelect = document.createElement('select');
	for (var i in JSDot.ViewTools.Layout) {
		layoutSelect.add(new Option(i), null);
	}
	layout.appendChild(layoutSelect);
	var layoutBtnApply = document.createElement('button');
	//layoutBtnApply.innerHTML = 'Apply';
	layout.appendChild(layoutBtnApply);
	$(layoutBtnApply).button({
		//'text': false,
		'icons': {'primary': 'ui-icon-check'},
		'label': 'Apply',
		}).click(function() {
			var tool = editor.view.getTool('Layout.'+layoutSelect.value, {});
			if (tool) tool.doLayout();
			$(this).blur();
		});


	/***********************/
	/* Extra tools section */
	/***********************/
	var extra = addSection('Tools', {'expanded': false}).content;
	
	var jsonBtn = document.createElement('button');
	jsonBtn.appendChild(document.createTextNode('Edit JSON'));
	extra.appendChild(jsonBtn);
	$(jsonBtn).button().click(function () {
			var jsonTool = editor.getTool('jsonDialog', {});
			if (jsonTool) jsonTool.show(editor.jsdot);
			});
	
	
	/** Toggle dialog.
		If it's closed open it, if it's open close it.
	*/
	this.toggleOpen = function() {
		if ($(dialog).dialog('isOpen')) {
			$(dialog).dialog('close');
		} else {
			$(dialog).dialog('open');
			handler.selectionchg();
		}
	};
	
	var handler = {
		selectionchg: function(/*n, s*/) {
		
			/* if closed then do not update */
			if (!$(dialog).dialog('isOpen')) return;
			
			var nnodes = 0, nedges = 0;
			editor.selection.forNodes(function(){ ++nnodes; });
			editor.selection.forEdges(function(){ ++nedges; });
			if (nnodes + nedges == 0) {
				msg.innerHTML = 'Nothing selected.';
				$(nodeForm).hide();
				$(edgeForm).hide();
			} else if (nnodes + nedges > 1) {
				/* multiple selection */
				$(nodeForm).hide();
				$(edgeForm).hide();
				msg.innerHTML = (nnodes ? nnodes+' node'+(nnodes>1 ? 's' : '')+(nedges ? ' and ' : '') : '')
						+ (nedges ? nedges+' edge'+(nedges>1 ? 's' : '') : '')
						+ ' selected.';
			} else {
				/* single selection, show properties */
				var e = editor.selection.selection[0];
				if (e.isNode) {
					/* selected node */
					msg.innerHTML = 'Node "'+e.name+'".';
					
					nodeFStcl.innerHTML = ''; /* remove options */
					for (var i in JSDot.stencils) {
						nodeFStcl.add(new Option(i, i, i == e.stencil), null);
					}
					
					$(nodeFLabel).blur(); /* if it has focus the value doesn't change */
					nodeFLabel.value = e.label.value;
					nodeFAttribsJSON.value = e.getData("data");
					
					$(edgeForm).hide();
					$(nodeForm).show();
					
				} else if (e.isEdge) {
					/* selected edge */
					msg.innerHTML = 'Edge "'+e.id+'".';
					
					edgeFStcl.innerHTML = '';
					for (var i in JSDot.edge_stencils) {
						edgeFStcl.add(new Option(i, i, i == e.stencil), null);
					}
					
					$(edgeFLabel).blur(); /* if it has focus the value doesn't change */
					edgeFLabel.value = (e.label ? e.label.value : '');
					edgeFAttribsCondition.value = e.getData("data");


					$(nodeForm).hide();
					$(edgeForm).show();
				}
			}
		},
		
		changed: function(w) {
			if (w == editor.selection.selection[0]) {
				/* the style of the selected node has changed */
				handler.selectionchg(); /* update form content */
			}
		},
	};
	
	var removeH = function() {
		handler.selectionchg();
	};
	
	editor.jsdot.addEventHandler(editor.view, handler);
	editor.jsdot.addEventHandler(editor.graph, 'removed', removeH);
	editor.jsdot.addEventHandler(editor.graph, 'newgraph', removeH); /* reuse handler */
	this.toggleOpen(); // closed on startup
};
/*
This file is part of the JSDot library

http://code.google.com/p/jsdot/

Copyright (c) 2010 Carlo Vanini

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/*
JSDot.EditTools.jsonDialog = function() {
};
//*/

JSDot.EditTools.jsonDialog = {

	show: function(jsdot) {
		var jsonTool = jsdot.getTool('json', {});
		var g = jsonTool.exportGraph();
		//var dialog = document.createElement('div');
		var text = document.createElement('textarea');
		text.value = g;
		var container = document.createElement('div');
		container.appendChild(text);
		
		function importGraph(clear) {
			if (clear) jsdot.graph.clear();
			var msg = null;
			switch (jsonTool.importGraph(text.value)) {
				case 0: /* ok */
					break;
				case 1:
					msg = "The input is not a well-formed representation of a graph.";
					break;
				case 2:
					msg = "The input contains nodes with duplicate names.";
					break;
				case 3:
					msg = "An edge link to an inexistent node.";
					break;
				default:
					msg = "Unknown error encountered.";
					break;
			}
			if (msg) {
				var div = document.createElement('div');
				div.appendChild(document.createTextNode(msg));
				$(div).dialog({
						modal: true,
						close: function() {
							$(div).dialog('destroy');
							div.parentNode.removeChild(div);
							},
						buttons: {
							Ok: function() {
								$(this).dialog('close');
							} }
						});
			} else {
				$(container).dialog('close');
			}

		};
		
		$(container).dialog({
				//'modal': true,
				'dialogClass': 'jsdot-editjson',
				'modal': true, /* options order matters! */
				'width': 600,
				'height': 400,
				'close': function() {
					$(container).dialog('destroy');
					container.parentNode.removeChild(container);
					},
				'buttons': {
					'Cancel': function () { $(container).dialog('close'); },
					'Import': function () { importGraph(false); },
					'Load': function () { importGraph(true); },
					},
				});
	},
};
